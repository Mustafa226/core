Concept for the registry of Entities (ID-Concept is a prerequisite to this):

Tables are:
* OrdinaryGroundAtomTable
  Stores:
    * String representation
    * Vector of (Constant/String/Integer) Term IDs (predicate = first term)
  Indices:
    * UNIQUE hash index (ensure that same ground atoms gets the same IDs)
    * String representation (lookup ID by atom string)
    * Predicate Term ID (lookup atoms with same predicate)
    * ?first/second/... argument Term ID (lookup atoms with same first/second/... argument)
* OrdinaryNongroundAtomTable
  Stores:
    * vector of Term IDs (predicate = first term)
  Indices:
    * Predicate Term ID (lookup atoms with same predicate)
    * ?first/second/... argument Term ID (lookup atoms with same first/second/... argument)
* BuiltinAtomTable
  Stores:
    * vector of Term IDs (predicate = first term)
  Indices:
    * ?Predicate Term ID (lookup builtins of same type)
    * ?first/second/... argument Term ID (lookup atoms with same first/second/... argument)
* AggregateAtomTable
  Stores:
    * Operator Constant Term ID (#max, #sum, ...)
    * Left/Right Comparison Operator Constant Term ID
    * Left/Right Term ID
    * list of Variable Term IDs (body variables)
    * list of Literal IDs (body condition)
  Indices:
    * ?Left/Right Variable Term IDs (lookup by free outer variables)
    * ?Literal nonbound Variable Term IDs (lookup by free inner variables)
    * ?Literal bound Variable Term IDs (lookup by bound inner variables)
* ExternalAtomTable
  Stores:
    * Constant Term ID (function)
    * vector of Term IDs (inputs)
    * vector of Term IDs (outputs)
  Indices:
    * Constant Term ID (lookup by function)
    * Term IDs (lookup by Terms in input)
    * Term IDs (lookup by Terms in output)
* ConstantTable
  Stores:
    * string
  Indices:
    * UNIQUE hash index (ensure that same constants get the same IDs)
    * String representation (lookup ID by constant string)
* StringTable
  Stores:
    * string
  Indices:
    * UNIQUE hash index (ensure that same strings get the same IDs)
    * String representation (lookup ID by string)
* VariableTable
  Stores:
    * string
  Indices:
    * UNIQUE hash index (ensure that same variables get the same IDs)
    * String representation (lookup ID by string)
* RuleTable
  Stores:
    * list of AtomIDs (disjunctive head)
    * list of LiteralIDs (conjunctive body)
    TODO weak
  Indices:
    TODO

Unique Index Overview:
* OrdinaryGroundAtomTable
* ConstantTable
* StringTable
* VariableTable

To access the tables, special inline functions in some Repository (manager singleton) should be used.
The storage of entities which have a unique index cannot be changed once they are in a table.
-> for these entities the lookup returns a const ref/iterator
-> for other entities the lookup returns a non-const ref/iterator or provides a possibility for storing back

Repository methods and complexity requirements:
* const StorageType& getByID<StorageType>(ID) const (call it getReadonlyByID?)
  O(1)
  assertion if StorageType and ID incompatible
  throws if ID not found
* StorageType& getByID<StorageType>(ID) (call it getModifyableByID?)
  O(1)
  assertion if StorageType and ID incompatible
  assertion if Table is unique hashed (can only return const)
  throws if ID not found
* void getCopyByID<StorageType>(ID, StorageType&)
  O(1+copying StorageType)
  assertion if StorageType and ID incompatible
  throws if ID not found
* store<StorageType>(const StorageType& entity)
  O(hash calc + lookup + insert(includes copy StorageType))
  determines table from StorageType
  calculates hash
  returns ID if existing
  inserts, calculates new ID and returns new ID if not existing
* getID<StorageType>(const StorageType& entity)
  O(hash calc + lookup)
  determines table from StorageType
  calculates hash
  returns ID if existing, -1 = ~0x0 otherwise
* TODO: index access functions

Open Questions:
* why do we split constant and string, but not rules?

  PS:
  some splits are necessary because we need extra addresses (e.g., ordinary ground atoms)
  other splits are useful because the entities are treated very differently (e.g., aggregate atoms vs external atoms)
  is the split between constant and string (and variable) necessary?
  could we need a split between rule and constraint and weak constraint?

* how do queries fit into the system? (we want to have them at some point)
  
  PS:
  they should fit pretty well as a new maintype (we have 4 unused maintypes)

* do we need a unique index on variables?

  PS:
  probably not, as this would be an ID distributed over various rules, where the variables are not related at all
  BUT: within one rule, the same variable should definitely get the same ID

