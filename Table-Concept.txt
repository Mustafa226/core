# -*- org -*-
#+STARTUP: showall

Concept for the registry of Entities (ID-Concept is a prerequisite to this):

* Tables
** OrdinaryGroundAtomTable
- Stores:
  - String representation
  - Tuple: vector of (Constant/String/Integer) Term (predicate =
    first term, arguments = tail)

- Indices:
  - UNIQUE hash index (ensure that same ground atoms gets the same
    IDs, hashed by Tuple)
  - String representation (lookup Term::id by atom string)
  - Predicate Term::id (lookup atoms with same predicate), grouped
    together for fast size checking of predicate extension using
    upper_bound() - lower_bound()
  - ?first/second/... argument Term ID (lookup atoms with same
    first/second/... argument)

** OrdinaryNongroundAtomTable
- Stores:
  - Tuple: vector of Term (predicate = first term, arguments = tail)

- Indices:
  - UNIQUE hash index (ensure that same nonground atoms gets the same
    IDs, hashed by Tuple)
  - Predicate Term (lookup atoms with same predicate, see above)
  - ?first/second/... argument Term ID (lookup atoms with same
    first/second/... argument)

- TODO can nonground and ground table be unified? -> PS: no, we want contiguious IDs for ground atoms (for bitset interpretations)

- TODO can we have different indices for different optimization
  settings? (turn some index off when this and that happens) -> PS: i guess this is only possible during compile time

** BuiltinAtomTable
- Stores:
  - Tuple: vector of Term (predicate = first term, arguments = tail)

- Indices:
  - ?Predicate Term ID (lookup builtins of same type)
  - ?first/second/... argument Term ID (lookup atoms with same
    first/second/... argument)

** AggregateAtomTable (see also work done by Luca)
- Stores:
  - Operator Constant Term ID (#max, #sum, ...)
  - Left/Right Comparison Operator Constant Term ID
  - Left/Right Term ID
  - list of Variable Term IDs (body variables)
  - list of Literal IDs (body condition)

- Indices:
  - ?Left/Right Variable Term IDs (lookup by free outer variables)
  - ?Literal nonbound Variable Term IDs (lookup by free inner variables)
  - ?Literal bound Variable Term IDs (lookup by bound inner variables)

** ExternalAtomTable
- Stores:
  - Constant Term ID (function)
  - vector of Term IDs (inputs)
  - vector of Term IDs (outputs)
  - pointer to plugin atom (stores which input is predicate, which is constant)

- Indices:
  - function Term ID
  - ?Term IDs (lookup by Terms in input)
  - ?Term IDs (lookup by Terms in output)

** TermTable (for all terms, except integers which are implicitly stored in IDs)
- Stores:
  - string (constant, string, or variable)
  - id (includes type, e.g., anonymous var)

- Indices:
  - UNIQUE hash index (ensure that same symbols get the same IDs)
  - String representation (lookup ID by string)

** RuleTable
- Stores:
  - list of AtomIDs (disjunctive head)
  - list of LiteralIDs (conjunctive body)
    TODO weak

- Indices:
  TODO

* Unique Index Overview
** OrdinaryGroundAtomTable
** SymbolTable


* Repository methods and complexity requirements

To access the tables, special inline functions in some Repository should be used.
The storage of entities which have a unique index cannot be changed once they are in a table.
-> for these entities the lookup returns a const ref/iterator
-> for other entities the lookup returns a non-const ref/iterator or provides a possibility for storing back

TK: We probably also need
to set all members of Term and Atom as const, so no-one can change
them once they are constructed.

PS: This is the idea of "assertion if Table is unique
hashed (can only return const)" below (terms and atoms cannot be modified
once they are in the table, so they can only be returned as copies not as
references).

** class Table<StorageType> with specializations for each storage type
** const StorageType& tbl.getByID(ID) const throw (NotFound)
   O(1)
   throws if ID not found

special functions of special tables:

** const OrdinaryAtom& OrdinaryGroundAtomTable::getByString(const std::string& str) const
** const OrdinaryAtom& OrdinaryGroundAtomTable::getByPredicate(ID term) const
** const OrdinaryAtom& OrdinaryNongroundAtomTable::getByPredicate(ID term) const
** const ExternalAtom& ExternalAtomTable::getByFunction(ID term) const

* Open Questions
** why do we split constant and string, but not rules?

  PS:
  some splits are necessary because we need extra addresses (e.g., ordinary ground atoms)
  other splits are useful because the entities are treated very differently (e.g., aggregate atoms vs external atoms)
  is the split between constant and string (and variable) necessary?
  could we need a split between rule and constraint and weak constraint?

  TK: it could be necessary for some optimization techniques to
  "force" some constraints into some components

** how do queries fit into the system? (we want to have them at some point)
  
  PS:
  they should fit pretty well as a new maintype (we have 4 unused
  maintypes)

  TK: second that

** do we need a unique index on variables?

  PS:
  probably not, as this would be an ID distributed over various rules, where the variables are not related at all
  BUT: within one rule, the same variable should definitely get the same ID

  TK: But I guess we need to standardize apart in order to get unique
  ids for the same non-ground atom. This is handy i guess for
  unification, as unifiable atoms must have the same node id in the
  depgraph. Hm, should we create an index of unifiable atoms???

  PS: this indexing should be achieved by indices into terms of the nonground atom table
  (see above: - Predicate Term (lookup atoms with same predicate, see above) - ?first/second/... argument Term ID (lookup atoms with same first/second/... argument))
