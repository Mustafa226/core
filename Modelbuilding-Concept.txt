# -*- org -*-
#+STARTUP: showall

Concept for building (TODO) and representing models:

* Interpretations/Models:
** Bit-Vectors will be used to represent sets of ground atoms
** We need Partial Models which then can be joined
** An atom can occur positive/negative/undefined,
   and an atom can be irrelevant (not part of the current component)
** Therefore we need a 4-valued representation (2 bits)
   * Knuth remarks in fascicle 1 pg 31, that it is better to have two vectors
     of bits, not one vector where even and odd bits have different meanings.
     (This appears to be correct in the next "first attempt" case.)
   * First attempt:
     Bit encoding:
     AB
     11 = irrelevant (not part of component)
     00 = undefined
     01 = positive
     10 = negative

     We have two bitsets, each of size n=|known ground atoms|:
     * one bitset for A bits
     * one bitset for B bits

     Joining two partial Models A1/B1 and A2/B2 works as follows:
     * compatibility check: ^ = bitwise xor, ~ = bitwise not
       SAME = ~(A1 ^ A2) & ~(B1 ^ B2)
       IRREL = (A1 & B1) |  (A2 & B2)
       COMPATIBLE = SAME | IRREL
       models are joinable iff COMPATIBLE contains no zero
     * calculating result model A'/B':
       A' = A1 & A2
       B' = B1 & B2
   * Second attempt:
     AB
     00 = irrelevant (not part of component)
     11 = undefined
     01 = positive
     10 = negative
     * compatibility check:
       DIFF = (A1 ^ A2) | (B1 ^ B2)
       NOTIRREL = (A1 | B1) & (A2 | B2)
       NONCOMPATIBLE = DIFF & NOTIRREL
       models are joinable iff NONCOMPATIBLE is zero
     * calculating result model A'/B':
       A' = A1 | A2
       B' = B1 | B2
     * calculation (in batches, keeping only A'/B'):
       calculate A1 ^ A2
       calculate B1 ^ B2
       OR these two
       calculate A1 | A2 and store in A'
       calculate B1 | B2 and store in B'
       AND these two
       AND to result of above OR
       check if all zeroes
       if not, discard
       if all batches ok, A'/B' is the result

     
PS: Can we do better in terms of bit encoding/join efficiency?
* First attempt: 3*n AND, 2*n OR, 2*n XOR, 2*n NOT, n ones-check, 2*n AND for actually joining.
* Second attempt: 2*n AND, 4*n OR, 2*n XOR, n zeroes-check, actual join happens during compatibility check.
     
