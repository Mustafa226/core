# -*- org -*-
#+STARTUP: showall

Concept for building (TODO) and representing models:

* Interpretations/Models:
** Bit-Vectors will be used to represent sets of ground atoms
** We need Partial Models which then can be joined
** An atom can occur positive/negative/undefined,
   and an atom can be irrelevant (not part of the current component)
** Therefore we need a 4-valued representation (2 bits)
	(see further down for 3-valued representation)
   * Knuth remarks in fascicle 1 pg 31, that it is better to have two vectors
     of bits, not one vector where even and odd bits have different meanings.
     (This appears to be correct in the next "first attempt" case.)
   * First attempt:
     Bit encoding:
     AB
     11 = irrelevant (not part of component)
     00 = undefined
     01 = positive
     10 = negative

     We have two bitsets, each of size n=|known ground atoms|:
     * one bitset for A bits
     * one bitset for B bits

     Joining two partial Models A1/B1 and A2/B2 works as follows:
     * compatibility check: ^ = bitwise xor, ~ = bitwise not
       SAME = ~(A1 ^ A2) & ~(B1 ^ B2)
       IRREL = (A1 & B1) |  (A2 & B2)
       COMPATIBLE = SAME | IRREL
       models are joinable iff COMPATIBLE contains no zero
     * calculating result model A'/B':
       A' = A1 & A2
       B' = B1 & B2
   * Second attempt:
     AB
     00 = irrelevant (not part of component)
     11 = undefined
     01 = positive
     10 = negative
     * compatibility check:
       DIFF = (A1 ^ A2) | (B1 ^ B2)
       NOTIRREL = (A1 | B1) & (A2 | B2)
       NONCOMPATIBLE = DIFF & NOTIRREL
       models are joinable iff NONCOMPATIBLE is zero
     * calculating result model A'/B':
       A' = A1 | A2
       B' = B1 | B2
     * calculation (in batches, keeping only A'/B'):
       calculate A1 ^ A2
       calculate B1 ^ B2
       OR these two
       calculate A1 | A2 and store in A'
       calculate B1 | B2 and store in B'
       AND these two
       AND to result of above OR
       check if all zeroes
       if not, discard
       if all batches ok, A'/B' is the result

     
PS: Can we do better in terms of bit encoding/join efficiency?
* First attempt: 3*n AND, 2*n OR, 2*n XOR, 2*n NOT, n ones-check, 2*n AND for actually joining.
* Second attempt: 2*n AND, 4*n OR, 2*n XOR, n zeroes-check, actual join happens during compatibility check.
     
** If we rewrite extended programs we only need something three-valued,
   and can (hopefully) do more efficient joins.
   An atom can occur positive, or it does not occur,
   and and an atom can be irrelevant (not part of the current component)
   * First attempt:
     AB
     00 = irrelevant (not part of component)
     01 = not present
     10 = positive present
     11 = unused/invalid combination
     * compatibility check:
       COMPAT = (A1 & B2) | (A2 & B1)
       models are joinable iff COMPAT is zero
     * calculating result model A'/B':
       A' = A1 | A2
       B' = B1 | B2
     * calculation (in batches):
       calculate A1 & B2
       calculate A2 & B1
       OR these two
       check if all zeroes
       if not, discard
       if all batches ok, A' = A1 | A2 and B' = B1 | B2 is the result
     * Operations: 2*n AND, n OR, n zero-check, 2*n OR for joining

* Online vs Offline Model Building
** We want to do both (either everything is online, or everything is offline)
** We do not want to implement everything twice
** Solution: For online model building we need kind of an Iterator interface:
   * initialize(bool retainModels)
   * getNextModel(...)
   * rewind()
   We can use this interface for offline model building:
   * we always retain models
   * we always obtain all models as soon as we setup such an iterator
   * -> for all iterators except the first layer, we iterate on retained models in some cache
   * -> we have a calculation localized to the current unit and its predecessors (this is beneficial to debugging)
   * -> we only need minimal implementation difference to get offline model building
   * -> we can later extend this to do on-demand evaluation plan building with offline model building (iterators must not refer to child evaluation units)
 
* Projected vs Not-Projected Model Building
** We want to do both (for each evaluation unit, switch on/off input and output projection independently)
** This should be as easy as doing it with one decision for the overall evaluation graph
** Projection can be handled by the iterators
** (PS) I have an idea for a joining input iterator which can handle model graphs with projection just as it handles model graphs without projection

