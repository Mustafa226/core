%{
/////////////////////////////////////////////////////////////////////////////
// DLVresultScanner.lpp

#include <stdio.h>
#include <assert.h>

#include "dlvhex/Term.h"
#include "dlvhex/Atom.h"
#include "dlvhex/AtomSet.h"
#include "dlvhex/DLVresultParser.h"

extern "C" int dlvresulterror(const char*);
extern "C" int dlvresultlex();

//extern unsigned parser_line;
//extern unsigned parser_errors;

// Max. length of numeric constants. This should match MAX_MAXINT.
#define NUM_LENGTH 9


// We don't need unput, and it can yield a "defined but not used"-warning.
#define YY_NO_UNPUT
%}

%option noyywrap
%option prefix="dlvresult" outfile="lex.yy.c"


NEWLINE     \15?\n
                        // some OSs use \r\n as end-of-line instead of \n

MSG         ([a-zA-Z/].+)
                        // need the slash for path-strings at the beginning!

ID          ([A-Za-z][A-Za-z_0-9]*)

QUOTED_ID   (\"[^\"]+\")

BLANK       ([ \t]+)

NUM         ([0-9]+)


%%

{NEWLINE}		{
                            return NEWLINE;
                            /* parser_line++;*/
                        }

","			{ return COMMA;		}
"-"			{ return TRUE_NOT;	}
"("			{ return PARAM_OPEN;	}
")"			{ return PARAM_CLOSE;	}
"{"			{ return CURLY_OPEN;	}
"}"			{ return CURLY_CLOSE;	}
{ID}			|
{QUOTED_ID}		{
                            dlvresultlval.string=new char[strlen(yytext)+1];
                            strcpy(dlvresultlval.string,yytext);
                            return ID;
			}

{NUM}			{ 
			    dlvresultlval.string=new char[strlen(yytext)+1];
                            strcpy(dlvresultlval.string,yytext);
                            return NUM; 
			}

{BLANK}			{ /* Skip blanks */	}


^{MSG}                  {
                            // something starting not with a '{' at the beginning of a line
                            // this is some dlv-(error-)message
                            dlvresultlval.string=new char[strlen(yytext)+1];
                            strcpy(dlvresultlval.string,yytext);
                            return MESSAGE;
                        }

.			{ // Anything not matching one of the patterns
			  // given above is considered an error.
			  char s[1024];

			  assert(yytext[1]==0);
			  sprintf(s,"syntax error (%s)",yytext); 
			  dlvresulterror(s);

                          //parser_errors++;
                          return ERROR;
			}
