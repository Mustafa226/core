/* -*- C++ -*- */

/**
 * @file   DLVresultScanner.lpp
 * @author Roman Schindlauer
 * @date   Thu Apr 13 14:48:51 CEST 2006
 * 
 * @brief  Defines FlexLexer::yylex() method.
 * 
 */


%{

#include <stdio.h>
#include <assert.h>

//
// generated from bison
//
#include "dlvhex/DLVresultParser.hpp"
#include "dlvhex/DLVresultFlexLexer.h"
#include "dlvhex/DLVresultParserDriver.h"


// Max. length of numeric constants. This should match MAX_MAXINT.
#define NUM_LENGTH 9


// We don't need unput, and it can yield a "defined but not used"-warning.
#define YY_NO_UNPUT


#define yylval (*(yy::DLVresultParser::semantic_type*)lexval)
#define yylloc ((yy::DLVresultParser::location_type*)lexloc)
#define driver (*lexdrv)

%}

/*
 * Because there is no #include-like feature we don't need yywrap, we don't need
 * unput either, and we parse an actual file, this is not an interactive session
 * with the user. Finally we enable the scanner tracing features.
 */
%option noyywrap nounput batch

/* %option debug */

/*
 * we use a custom FlexLexer (see DLVresultFlexLexer.h)
 */
%option c++

%option prefix="dlv"
%option yyclass="DLVresultFlexLexer"


NEWLINE     \15?\n
                        // some OSs use \r\n as end-of-line instead of \n

MSG         ([a-zA-Z/].+)
                        // need the slash for path-strings at the beginning!

ID          ([A-Za-z][A-Za-z_0-9]*)

QUOTED_ID   (\"[^\"]*\")

BLANK       ([ \t]+)

NUM         ([0-9]+)


%%

%{
  // abbreviate it as token
  typedef yy::DLVresultParser::token token;
%}


{NEWLINE} {
    return token::NEWLINE;
    /* parser_line++;*/
}

","     { return token::COMMA;         }
"-"     { return token::TRUE_NOT;      }
"("     { return token::PARAM_OPEN;    }
")"     { return token::PARAM_CLOSE;   }
"{"     { return token::CURLY_OPEN;    }
"}"     { return token::CURLY_CLOSE;   }

^{MSG} {
    // something starting not with a '{' at the beginning of a line
    // this is some dlv-(error-)message
    yylval.string = new std::string(yytext);
    return token::MESSAGE;
}

{ID} |
{QUOTED_ID} {
//    yylval.string = new std::string(yytext);
    yylval.charp = strdup(yytext);
    return token::ID;
}

{NUM} { 
    yylval.integ = new int(atoi(yytext));
    return token::NUM; 
}

{BLANK} { /* Skip blanks */ }


. { // Anything not matching one of the patterns
    // given above is considered an error.

    assert(yytext[1]==0);
    driver.error(*yylloc, "invalid character");
}

