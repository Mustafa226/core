/* dlvhex -- Answer-Set Programming with external interfaces.
 * Copyright (C) 2005, 2006, 2007 Roman Schindlauer
 * 
 * This file is part of dlvhex.
 *
 * dlvhex is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * dlvhex is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with dlvhex; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */


/**
 * @file   DLVresultScanner.lpp
 * @author Roman Schindlauer
 * @date   Thu Apr 13 14:48:51 CEST 2006
 * 
 * @brief  Defines FlexLexer::yylex() method.
 * 
 */


%{

#include <stdio.h>
#include <assert.h>

//
// generated from bison
//
#include "dlvhex/DLVresultParser.hpp"
#include "dlvhex/DLVresultFlexLexer.h"
#include "dlvhex/DLVresultParserDriver.h"


// Max. length of numeric constants. This should match MAX_MAXINT.
#define NUM_LENGTH 9


// We don't need unput, and it can yield a "defined but not used"-warning.
#define YY_NO_UNPUT


#define yylval (*(yy::DLVresultParser::semantic_type*)lexval)
#define yylloc ((yy::DLVresultParser::location_type*)lexloc)
#define driver (*lexdrv)

%}

/*
 * Because there is no #include-like feature we don't need yywrap, we don't need
 * unput either, and we parse an actual file, this is not an interactive session
 * with the user. Finally we enable the scanner tracing features.
 */
%option noyywrap nounput batch

/* %option debug */

/*
 * we use a custom FlexLexer (see DLVresultFlexLexer.h)
 */
%option c++

%option prefix="dlv"
%option yyclass="DLVresultFlexLexer"


NEWLINE     \15?\n
                        // some OSs use \r\n as end-of-line instead of \n

MSG         ([a-zA-Z/].+)
                        // need the slash for path-strings at the beginning!

ID          ([A-Za-z][A-Za-z_0-9]*)

QUOTED_ID   (\"[^\"]*\")

BLANK       ([ \t]+)

NUM         ([0-9]+)


%%

%{
  // abbreviate it as token
  typedef yy::DLVresultParser::token token;
%}


{NEWLINE} {
    return token::NEWLINE;
    /* parser_line++;*/
}

","     { return token::COMMA;         }
"-"     { return token::TRUE_NOT;      }
"("     { return token::PARAM_OPEN;    }
")"     { return token::PARAM_CLOSE;   }
"{"     { return token::CURLY_OPEN;    }
"}"     { return token::CURLY_CLOSE;   }

^{MSG} {
    // something starting not with a '{' at the beginning of a line
    // this is some dlv-(error-)message
    yylval.string = new std::string(yytext);
    return token::MESSAGE;
}

{ID} |
{QUOTED_ID} {
//    yylval.string = new std::string(yytext);
    yylval.charp = strdup(yytext);
    return token::ID;
}

{NUM} { 
    yylval.integ = atoi(yytext);
    return token::NUM; 
}

{BLANK} { /* Skip blanks */ }


. { // Anything not matching one of the patterns
    // given above is considered an error.

    assert(yytext[1]==0);
    driver.error(*yylloc, "invalid character");
}


%%

// Local Variables:
// mode: C++
// End:
