/* dlvhex -- Answer-Set Programming with external interfaces.
 * Copyright (C) 2005, 2006, 2007 Roman Schindlauer
 * 
 * This file is part of dlvhex.
 *
 * dlvhex is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * dlvhex is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with dlvhex; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */


/**
 * @file   HexParser.ypp
 * @author Roman Schindlauer
 * @date   Tue Mar 21 22:05:23 CET 2006
 * 
 * @brief  A bison C++ parser.
 * 
 */



//
// select the C++ parser LALR(1) skeleton
//
%skeleton "lalr1.cc"

//
// overwrite bison default class name "parser":
//
%define "parser_class_name" "HexParser"

//
// produce header file for the scanner
//
%defines

//
// Specify a prefix to use for all bison output file names
//
%file-prefix = "HexParser"

%{
#include <iostream>
#include <sstream>

#include "dlvhex/HexParserDriver.h"
#include "dlvhex/Term.h"
#include "dlvhex/Atom.h"
#include "dlvhex/ExternalAtom.h"
#include "dlvhex/AggregateAtom.h"
#include "dlvhex/BuiltinPredicate.h"
#include "dlvhex/Literal.h"
#include "dlvhex/Rule.h"
#include "dlvhex/Constraint.h"
#include "dlvhex/WeakConstraint.h"
#include "dlvhex/Program.h"
#include "dlvhex/Error.h"
#include "dlvhex/Registry.h"
#include "dlvhex/globals.h"


//////////////////////////////////////////////////////////////////////////////

%}

// this is the parsing context, passed as parameters to the
// yy::HexParser ctor
%parse-param { DLVHEX_NAMESPACE HexParserDriver* driver }
%parse-param { DLVHEX_NAMESPACE Program& program }
%parse-param { DLVHEX_NAMESPACE AtomSet& EDB }


// bison passes the driver as additional parameter to the lexer
// function YY_DECL, so we can abuse the driver to get the real lexer
// object and call the yylex() method
%lex-param   { DLVHEX_NAMESPACE HexParserDriver* driver }

// use a yy::location object to keep track of the location information
%locations

// debug parser
//%debug
//%error-verbose
//%verbose /* really verbose output */


%union {
    std::string*      string;
    int               integer;
    DLVHEX_NAMESPACE BaseAtom*         atom;
    DLVHEX_NAMESPACE Term*             term;
    DLVHEX_NAMESPACE Tuple*            terms;
    DLVHEX_NAMESPACE ExternalAtom*     extatom;
    DLVHEX_NAMESPACE BaseLiteral*      literal;
    DLVHEX_NAMESPACE Head*             disjunction;
    DLVHEX_NAMESPACE Body*             body;
    DLVHEX_NAMESPACE BaseRule*         rule;
    DLVHEX_NAMESPACE WeakConstraint*   wconstraint;
    DLVHEX_NAMESPACE BuiltinPredicate* builtin;
    DLVHEX_NAMESPACE AggregateAtom*    aggregate;
    /*
    unsigned       integer;
    WEIGHTS*       weights;
    OIDindices*    oids;
    */
    }


// define FlexLexer part *after* the definitions of the various types
%{

#include "dlvhex/HexFlexLexer.h"

//
// Flex expects the signature of yylex to be defined in the macro YY_DECL, and
// the C++ parser expects it to be declared.
//
// Announce to bison the prototype we want for the lexing function
#ifndef YY_DECL
#define YY_DECL                                                 \
yy::HexParser::token_type                                       \
yylex (yy::HexParser::semantic_type* yylval,                    \
       yy::HexParser::location_type* yylloc,                    \
       DLVHEX_NAMESPACE HexParserDriver* driver)
// declare YY_DECL function for the parser
YY_DECL;
#endif

DLVHEX_NAMESPACE_USE

%}

%token <string> ID EXTERNAL_ATOM_ID
%token <integer> NUM
%type  <string> ident
%type  <term> binop
%type  <integer> number
%type  <term> term
%type  <term> ident_or_fixedpt ident_or_number
%type  <terms> terms
%type  <atom> propositional_atom user_pred
%type  <literal> literal
%type  <disjunction> disj
%type  <body> body
%type  <rule> rule rule0 constraint
%type <wconstraint> wconstraint
%type <extatom> external_atom    
%type <terms> external_output
%type <builtin> builtin_pred    
%type  <string> aggregate_type
%type  <aggregate> aggregate_pred
%type  <aggregate> aggregate
%type  <term> fixedpt

//
// still from dlv, unused yet or forever:
//

//%type  <terms> terms1 terms2 terms3
//%type  <string> MAXINTEGER_EQUALS_param
//%type  <string> tertop
//%type  <string> user_pred builtin_pred propositional_atom aggregate external_atom
//%type  <string> builtin_pred
//%type  <string> param_sans_maxint
//%type  <string> strictrule
//%type  <string> weights
//%type  <string> object_id
//%type  <string> object_ids inherit


%token ERROR

%token NEWLINE
%token COMMA DOT COLON SEMICOLON EXCLAMATION PLUS ASTERISK EQUALS VERTICAL_BAR AMPERSAND

%token ID_OR_VEL CONS WEAK_CONS ANON_VAR
%token PARAM_OPEN PARAM_CLOSE
%token BRACKET_OPEN BRACKET_CLOSE
%token CURLY_OPEN CURLY_CLOSE
%token PRED_EQUAL PRED_UNEQUAL PRED_LESS PRED_GREATER
%token PRED_LESS_OR_EQ PRED_GREATER_OR_EQ
%token PRED_INT PRED_SUCC
%token <string> PRED_ANY PRED_AVG PRED_COUNT PRED_MAX PRED_MIN PRED_SUM PRED_TIMES
%token NOT TRUE_NOT
%token MAXINTEGER
%token NAMESPACE EXT_INCLUDE SHARP

%token BOOL_QUERY
%token META_IMPORT META_EXPORT

%token EXT_MAPPING_OP_PLUS EXT_MAPPING_OP_MINUS

%start input

// automagically delete all dynamically allocated objects after the
// parsing process (but keep those identifier terms, they are passed
// on to the individuals)
//
// doesn't work!
//
//%destructor { delete $$; } ident

// in debugging mode output the content of the corresponding terminal
// symbol
//%printer    { debug_stream() << *$$; } STRING
//%printer    { debug_stream() << $$; } NUMBER

%%

HEAD_SEPARATOR  : ID_OR_VEL | VERTICAL_BAR | SEMICOLON;

TAIL_SEPARATOR  : COMMA;

PARAM_SEPARATOR : COMMA;


input:
     | input line
//     | error { parser_errors++; }
     ;


line:
    clause
    | namespace
    | maxinteger
//          | query
    ;

maxinteger:
    MAXINTEGER EQUALS number
        {
	  ///@todo pure hack
            std::stringstream minum;

            minum << $3;

            Globals::Instance()->maxint = "#maxint=" + minum.str() + ".";
        }
    ;

namespace:
    NAMESPACE PARAM_OPEN nsdef PARAM_CLOSE NEWLINE
    ;

nsdef:
    ident COMMA ident 
        {
            std::string prefix(*$1);
            std::string ns(*$3);

            if (prefix[0] == '\"')
                prefix = prefix.substr(1, prefix.length() - 2);

            if (ns[0] == '\"')
                ns = ns.substr(1, ns.length() - 2);

            Term::namespaces.push_back(std::pair<std::string, std::string>(ns, prefix));

            delete $1;
            delete $3;
        }
//    | ident { Term::namespaces.push_back(std::pair<std::string, std::string>($1, "")); }
    ;

clause:
    rule
    {
      RulePtr rp($1);
      program.push_back(rp);
    }
    | constraint
    {
      RulePtr rp($1);
      program.push_back(rp);
    }
    | wconstraint
    {
      RulePtr rp($1);
      program.push_back(rp);
    }
    ;

//meta_rule : import
//          | export
//          ;

/* import    : META_IMPORT PARAM_OPEN ID COMMA ID COMMA ID COMMA ID COMMA ID
 *             COMMA ID PARAM_CLOSE DOT;
 * export    : META_EXPORT PARAM_OPEN ID COMMA ID COMMA ID COMMA ID COMMA ID
 *             PARAM_CLOSE DOT
 *           | META_EXPORT PARAM_OPEN ID COMMA ID COMMA ID COMMA ID COMMA ID
 *             COMMA ID PARAM_CLOSE DOT
 *           ;
 */


/*
strictrule: rule0 EXCLAMATION
          ;
*/


rule:
    rule0 DOT
    ;

constraint:
    CONS body DOT
        {
	  BodyPtr bp($2);
	  // create new constraint
	  $$ = new Constraint(bp);
        }
    ;

wconstraint:
    WEAK_CONS body DOT
        {
	  BodyPtr bp($2);
	  $$ = new WeakConstraint(bp, Term(1), Term(1));
        }
    | WEAK_CONS body DOT BRACKET_OPEN COLON ident_or_number BRACKET_CLOSE
        {
	  BodyPtr bp($2);
	  $$ = new WeakConstraint(bp, Term(1), *$6);
	  delete $6;
        }
    | WEAK_CONS body DOT BRACKET_OPEN ident_or_fixedpt COLON BRACKET_CLOSE
        {
	  BodyPtr bp($2);
	  $$ = new WeakConstraint(bp, *$5, Term(1));
	  delete $5;
        }
    | WEAK_CONS body DOT BRACKET_OPEN ident_or_fixedpt COLON ident_or_number BRACKET_CLOSE
        {
	  BodyPtr bp($2);
	  $$ = new WeakConstraint(bp, *$5, *$7);
	  delete $5;
	  delete $7;
        }
    ;

ident_or_fixedpt:
    ident
        {
            $$ = new Term(*$1);
            delete $1;
        }
    | fixedpt
    ;

ident_or_number:
    ident
        {
            $$ = new Term(*$1);
            delete $1;
        }
    | number
        {
            $$ = new Term($1);
        }
    ;

fixedpt:
    number
        {
            $$ = new Term($1);
        }
 /* | number DOT NUM */
    ;

/*

query     : body BOOL_QUERY
          ;
*/

rule0:
    user_pred
        {
            if (!$1->isGround())
	      {
                error(yylloc, "fact not safe");
	      }

            AtomPtr ap($1);
            EDB.insert(ap);
        }
    | user_pred CONS
        {
            if (!$1->isGround())
	      {
                error(yylloc, "fact not safe");
	      }

	    AtomPtr ap($1);
            EDB.insert(ap);
        }
    | user_pred CONS body
        {
	  //
	  // create rule head and add atom pointer to rule head
          //
	  AtomPtr ap($1);
	  HeadPtr hp(new Head(1, ap));
	  BodyPtr bp($3);
	  //
	  // create new rule with head and body
	  //
	  $$ = new Rule(hp, bp);
        }
    | disj
        {
	  // empty body
	  BodyPtr bp(new Body);

	  HeadPtr hp($1);

	  //
	  // create new rule with head and empty body
	  //
	  $$ = new Rule(hp, bp);
        }
    | disj CONS
        {
	  // empty body
	  BodyPtr bp(new Body);

	  HeadPtr hp($1);

	  //
	  // create new rule with head and empty body
	  //
	  $$ = new Rule(hp, bp);
        }
    | disj CONS body
        {
	  HeadPtr hp($1);
	  BodyPtr bp($3);
	  
	  //
	  // create new rule
	  //
	  $$ = new Rule(hp, bp);
        }
//    | ident PARAM_OPEN number_param DOT DOT number_param PARAM_CLOSE
    ;

disj:
    user_pred HEAD_SEPARATOR user_pred
    {
      //
      // create rule head
      //
      $$ = new Head;
      
      //
      // add both atom pointers to rule head
      //
      AtomPtr ap1($1);
      AtomPtr ap2($3);
      $$->push_back(ap1);
      $$->push_back(ap2);
    }
    | disj HEAD_SEPARATOR user_pred
    {
      $$ = $1;

      //
      // add atom pointer to rule head
      //
      AtomPtr ap($3);
      $$->push_back(ap);
    }
    ;


body:
    literal
    {
      LiteralPtr lp($1);

      //
      // create rule body
      //
      $$ = new Body;
      
      //
      // add literal pointer
      //
      $$->push_back(lp);
    }
    | body TAIL_SEPARATOR literal
    {
      LiteralPtr lp($3);

      $$ = $1;
      
      //
      // add literal pointer to existing rule body
      //
      $$->push_back(lp);
    }
    ;


literal:
    user_pred
        {
	  AtomPtr ap($1);

	  //
	  // create positive literal with atom
	  //
	  $$ = new Literal<Positive>(ap);
        }
    | NOT user_pred
        {
	  AtomPtr ap($2);

	  //
	  // create weakly negated literal with atom
	  //
	  $$ = new Literal<Negative>(ap);
        }
    | external_atom
        {
	  AtomPtr ap($1);

	  //
	  // create positive literal with external atom
	  //
	  $$ = new Literal<Positive>(ap);
        }
    | NOT external_atom
        {
	  AtomPtr ap($2);
	  
	  //
	  // create weakly negated literal with external atom
	  //
	  $$ = new Literal<Negative>(ap);
        }
    | builtin_pred
        {
	  AtomPtr ap($1);

	  //
	  // create literal with builtin predicate
	  //
	  $$ = new Literal<Positive>(ap);
        }
    | aggregate
        {
	  AtomPtr ap($1);

	  //
	  // create positive aggregate
	  //
	  $$ = new Literal<Positive>(ap);
        }
    | NOT aggregate
        {
	  AtomPtr ap($2);

	  //
	  // create negated aggregate
	  //
	  $$ = new Literal<Negative>(ap);
        }
    ;
          


user_pred:
    propositional_atom
    {
      //
      // pass the already created atom
      //
      $$ = $1;
    }
    | PARAM_OPEN terms PARAM_CLOSE
    {
      //
      // create atom from a tuple
      //
      try
	{
	  $$ = new Atom<Positive>(*$2);
	}
      catch (SyntaxError& e)
	{
	  error(yylloc, e.what());
	}
      
      delete $2;
    }
    | ident PARAM_OPEN terms PARAM_CLOSE
    {
      //
      // create atom from predicate name and arguments
      //
      try
	{
	  $$ = new Atom<Positive>(Term(*$1), *$3);
	}
      catch (SyntaxError& e)
	{
	  error(yylloc, e.what());
	}
      
      delete $1;
      delete $3;
    }
    | TRUE_NOT PARAM_OPEN terms PARAM_CLOSE
    {
      //
      // create negated atom from a tuple
      //
      try
	{
	  $$ = new Atom<Negative>(*$3);
	}
      catch (SyntaxError& e)
	{
	  error(yylloc, e.what());
	}
      
      delete $3;
    }
    | TRUE_NOT ident PARAM_OPEN terms PARAM_CLOSE
    {
      //
      // create negated atom from predicate name and arguments
      //
      try
	{
	  $$ = new Atom<Negative>(Term(*$2), *$4);
	}
      catch (SyntaxError& e)
	{
	  error(yylloc, e.what());
	}
      
      delete $2;
      delete $4;
    }
    | PRED_INT PARAM_OPEN term PARAM_CLOSE
    {
      //
      // create atom from a term
      //
//       Tuple t;
//       t.push_back(*$3);
//       $$ = new Atom("#int", t);
//       $$->setAlwaysFO();

      ///@todo fix #int
      delete $3;
    }
    ;


external_atom:
    AMPERSAND ident BRACKET_OPEN terms BRACKET_CLOSE external_output
        {
            /// @todo two external atoms with same name and input?
            /// how "equal" are they?

            //
            // create new external atom from:
            // name string
            // input parameters
            // arguments
            //
            try
            {
	      $$ = new ExternalAtom(Term(*$2), *$6, *$4);
            }
            catch (SyntaxError& e)
            {
                error(yylloc, e.what());
            }

            delete $2;
            delete $4;
            delete $6;
        }
    ;


external_output:
        {
	  //
	  // emtpy tuple
	  //
	  $$ = new Tuple;
        }
    | PARAM_OPEN PARAM_CLOSE
        {
	  //
	  // emtpy tuple
	  //
	  $$ = new Tuple;
        }
    | PARAM_OPEN terms PARAM_CLOSE
        {
	  $$ = $2;
        }
    ;


propositional_atom:
    ident
        {
            //
            // construction of an atom could throw an exception - don't throw
            // same exception again, but use bison's error handler as a general
            // interface for all errors that happen within the parsing.
            ///@todo not true anymore
            try
	      {
		//
		// create new atom from string
		//
                $$ = new Atom<Positive>(*$1);

		///@todo hm, removed the SyntaxErrors from Atom<>:
		///non-ground propositional variables should be
		///allowed?
		if ($$->getPredicate().isVariable())
		  {
		    error(yylloc, "propositional Atom must be ground. Probably not a HEX-program?");
		  }
	      }
            catch (SyntaxError& e)
	      {
                error(yylloc, e.what());
	      }

            delete $1;
        }
    | TRUE_NOT ident
        {
	  //
	  // create new negated atom from string
	  // 
	  $$ = new Atom<Negative>(*$2);

	  delete $2;
        }
    ;



builtin_pred:
    term binop term
        {
            $$ = new BuiltinPredicate(*$1, *$2, *$3);

            delete $1;
            delete $2;
            delete $3;
        } 
    | binop PARAM_OPEN term PARAM_SEPARATOR term PARAM_CLOSE
        {
            $$ = new BuiltinPredicate(*$3, *$1, *$5);

            delete $1;
            delete $3;
            delete $5;
        }
/*          | PRED_SUCC terms2
          | tertop terms3
          | param_sans_maxint EQUALS term tertop term
          | MAXINTEGER_EQUALS_param tertop term
          */
	  ;

aggregate:
    term PRED_LESS aggregate_pred
        {
            $3->setComp("<", "");
            $3->setLeftTerm(*$1);
            $$ = $3;
            delete $1;
        }
    | term PRED_LESS_OR_EQ aggregate_pred
        {
            $3->setComp("<=", "");
            $3->setLeftTerm(*$1);
            $$ = $3;
            delete $1;
        }
    | term EQUALS aggregate_pred
        {
            $3->setComp("=", "");
            $3->setLeftTerm(*$1);
            $$ = $3;
            delete $1;
        }
    | term PRED_GREATER_OR_EQ aggregate_pred
        {
            $3->setComp(">=", "");
            $3->setLeftTerm(*$1);
            $$ = $3;
            delete $1;
        }
    | term PRED_GREATER aggregate_pred
        {
            $3->setComp(">", "");
            $3->setLeftTerm(*$1);
            $$ = $3;
            delete $1;
        }
    | aggregate_pred PRED_LESS term
        {
            $1->setComp("", "<");
            $1->setRightTerm(*$3);
            $$ = $1;
            delete $3;
        }
    | aggregate_pred PRED_LESS_OR_EQ term
        {
            $1->setComp("", "<=");
            $1->setRightTerm(*$3);
            $$ = $1;
            delete $3;
        }
    | aggregate_pred EQUALS term
        {
            $1->setComp("", "=");
            $1->setRightTerm(*$3);
            $$ = $1;
            delete $3;
        }
    | aggregate_pred PRED_GREATER_OR_EQ term
        {
            $1->setComp("", ">=");
            $1->setRightTerm(*$3);
            $$ = $1;
            delete $3;
        }
    | aggregate_pred PRED_GREATER term
        {
            $1->setComp("", ">");
            $1->setRightTerm(*$3);
            $$ = $1;
            delete $3;
        }
    | term PRED_LESS aggregate_pred PRED_LESS term
        {
            $3->setComp("<", "<");
            $3->setLeftTerm(*$1);
            $3->setRightTerm(*$5);
            $$ = $3;
            delete $1;
            delete $5;
        }
    | term PRED_LESS aggregate_pred PRED_LESS_OR_EQ term
        {
            $3->setComp("<", "<=");
            $3->setLeftTerm(*$1);
            $3->setRightTerm(*$5);
            $$ = $3;
            delete $1;
            delete $5;
        }
    | term PRED_LESS_OR_EQ aggregate_pred PRED_LESS term
        {
            $3->setComp("<=", "<");
            $3->setLeftTerm(*$1);
            $3->setRightTerm(*$5);
            $$ = $3;
            delete $1;
            delete $5;
        }
    | term PRED_LESS_OR_EQ aggregate_pred PRED_LESS_OR_EQ term
        {
            $3->setComp("<=", "<=");
            $3->setLeftTerm(*$1);
            $3->setRightTerm(*$5);
            $$ = $3;
            delete $1;
            delete $5;
        }
    ;

binop:
    PRED_EQUAL { $$ = new Term("="); }
    | EQUALS { $$ = new Term("="); }
    | PRED_UNEQUAL { $$ = new Term("!="); }
    | PRED_LESS { $$ = new Term("<"); }
    | PRED_GREATER { $$ = new Term(">"); }
    | PRED_LESS_OR_EQ { $$ = new Term("<="); }
    | PRED_GREATER_OR_EQ { $$ = new Term(">="); }
    ;

/*
tertop   : PLUS
         | ASTERISK
	 ;
*/

aggregate_pred:
aggregate_type CURLY_OPEN terms COLON body CURLY_CLOSE
{
  //
  // in higher-order mode we cannot have aggregates, because then they would
  // almost certainly be recursive, because of our atom-rewriting!
  //
  if (Globals::Instance()->getOption("NoPredicate"))
    {
      error(yylloc, "Aggregates only allowed in FO-mode (use --firstorder)");
    }

  try
    {
      Term type(*$1);
      BodyPtr bp($5);
      $$ = new AggregateAtom(type, *$3, bp);
      delete $1;
      delete $3;
    }
  catch (SyntaxError& e)
    {
      error(yylloc, e.what());
    }
  
  delete $1;
  delete $3;
  delete $5;
}
;

aggregate_type:
    PRED_ANY
    | PRED_AVG
    | PRED_COUNT
    | PRED_MAX
    | PRED_MIN
    | PRED_SUM                   
    | PRED_TIMES
    ;



terms:
    term
        {
            $$ = new Tuple;

            //
            // tuple is a vector, term is copied
            //
            $$->push_back(*$1);

            delete $1;
        }
    | terms PARAM_SEPARATOR term
        {
            $$ = $1;

            //
            // tuple is a vector, term is copied
            //
            $$->push_back(*$3);

            delete $3;
        }
    ;


term:
    ident
        {
            //
            // make a string term
            //
            $$ = new Term(*$1);

            delete $1;
        }
    | number
        {
            //
            // make a number term
            //
            $$ = new Term($1);
        }
    | ANON_VAR
        {
            //
            // Default constructor makes anonymous term
            //
            $$ = new Term();
        }
//         | maxinteger
//         | TRUE_NOT term
    ;


/*
param_sans_maxint : ident
         | number_param
         | ANON_VAR
         ;
*/


ident:
    ID
        {
            $$ = $1;
        }
    | ID_OR_VEL
        {
            $$ = new std::string("v");
        }
    ; 

    /*
number_param:
    number
        {
            $$ = $1;
        }
    ;
    */

number :
    NUM 
    ;



%%


//
// error method of bison parser -> call error method of the
// corresponding driver
//
void
yy::HexParser::error(const yy::HexParser::location_type& l,
                     const std::string& m)
{
    driver->error(l, m);
}


//
// abuse YY_DECL as bison callback for a pure C++ parsing engine
//
YY_DECL
{
    HexFlexLexer* lex = driver->getLexer();
    lex->lexval = yylval; // set current semantic value
    lex->lexloc = yylloc; // and the current location,
    return (yy::HexParser::token_type) lex->yylex (); // finally call the drivers lexer
} 



// Local Variables:
// mode: C++
// End:
