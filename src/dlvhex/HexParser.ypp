/* -*- C++ -*- */

/**
 * @file   HexParser.ypp
 * @author Roman Schindlauer
 * @date   Tue Mar 21 22:05:23 CET 2006
 * 
 * @brief  A bison C++ parser.
 * 
 */



//
// select the C++ parser LALR(1) skeleton
//
%skeleton "lalr1.cc"

//
// overwrite bison default class name "parser":
//
%define "parser_class_name" "HexParser"

//
// produce header file for the scanner
//
%defines

//
// Specify a prefix to use for all bison output file names
//
%file-prefix = "HexParser"

%{
#include <iostream>
#include <sstream>

#include "dlvhex/HexParserDriver.h"
#include "dlvhex/Term.h"
#include "dlvhex/Atom.h"
#include "dlvhex/Literal.h"
#include "dlvhex/Rule.h"
#include "dlvhex/Program.h"
#include "dlvhex/ExternalAtom.h"
#include "dlvhex/Error.h"
#include "dlvhex/Registry.h"
#include "dlvhex/globals.h"


//
// Flex expects the signature of yylex to be defined in the macro YY_DECL, and
// the C++ parser expects it to be declared.
//
// Announce to bison the prototype we want for the lexing function
#ifndef YY_DECL
#define YY_DECL                                                         \
  int yylex (YYSTYPE* yylval,                                           \
             yy::location* yylloc,                                      \
             HexParserDriver* driver)
// declare YY_DECL function for the parser
YY_DECL;
#endif


//////////////////////////////////////////////////////////////////////////////

%}

// this is the parsing context, passed as parameters to the
// yy::HexParser ctor
%parse-param { HexParserDriver* driver }
%parse-param { Program& program }
%parse-param { AtomSet& EDB }


// bison passes the driver as additional parameter to the lexer
// function YY_DECL, so we can abuse the driver to get the real lexer
// object and call the yylex() method
%lex-param   { HexParserDriver* driver }

// use a yy::location object to keep track of the location information
%locations

// debug parser
//%debug
//%error-verbose
//%verbose /* really verbose output */


%union {
    std::string*      string;
    int*              integ;
    AtomPtr*          atom;
    Term*             term;
    Tuple*            terms;
    ExternalAtom*     extatom;
    Literal*          literal;
    RuleHead_t*       disjunction;
    RuleBody_t*       body;
    Rule*             rule;
    WeakConstraint*   wconstraint;
    BuiltinPredicate* builtin;
    /*
    AGGREGATE_TYPE*aggregate_type;
    AGGREGATEPRED* aggregate_pred;
    unsigned       integer;
    WEIGHTS*       weights;
    OIDindices*    oids;
    */
    }

%token <string> ID EXTERNAL_ATOM_ID
%token <integ> NUM
%type  <string> ident
%type  <string> binop
%type  <integ> number
//%type  <string> param_sans_maxint
%type  <term> term
//%type  <string> MAXINTEGER_EQUALS_param
%type  <term> ident_or_fixedpt ident_or_number
//%type  <string> tertop
%type  <terms> terms// terms1 terms2 terms3
//%type  <string> user_pred builtin_pred propositional_atom aggregate external_atom
%type  <atom> propositional_atom user_pred
//%type  <string> builtin_pred aggregate
%type  <literal> literal
%type  <disjunction> disj
%type  <body> body
%type  <rule> rule rule0 constraint
%type <wconstraint> wconstraint
%type <extatom> external_atom    
%type <terms> external_output
%type <builtin> builtin_pred    
//%type  <string> aggregate_type
//%type  <string> aggregate_pred
//%type  <string> strictrule
//%type  <string> weights
%type  <term> fixedpt
//%type  <string> object_id
//%type  <string> object_ids inherit


%token ERROR

%token NEWLINE
%token COMMA DOT COLON SEMICOLON EXCLAMATION PLUS ASTERISK EQUALS VERTICAL_BAR AMPERSAND

%token ID_OR_VEL CONS WEAK_CONS ANON_VAR
%token PARAM_OPEN PARAM_CLOSE
%token BRACKET_OPEN BRACKET_CLOSE
%token CURLY_OPEN CURLY_CLOSE
%token PRED_EQUAL PRED_UNEQUAL PRED_LESS PRED_GREATER
%token PRED_LESS_OR_EQ PRED_GREATER_OR_EQ
%token PRED_INT PRED_SUCC
%token PRED_ANY PRED_AVG PRED_COUNT PRED_MAX PRED_MIN PRED_SUM PRED_TIMES
%token NOT TRUE_NOT
%token MAXINTEGER
%token NAMESPACE EXT_INCLUDE SHARP

%token BOOL_QUERY
%token META_IMPORT META_EXPORT

%token EXT_MAPPING_OP_PLUS EXT_MAPPING_OP_MINUS

%start input

// automagically delete all dynamically allocated objects after the
// parsing process (but keep those identifier terms, they are passed
// on to the individuals)
//
// doesn't work!
//
//%destructor { delete $$; } ident

// in debugging mode output the content of the corresponding terminal
// symbol
//%printer    { debug_stream() << *$$; } STRING
//%printer    { debug_stream() << $$; } NUMBER

%%

HEAD_SEPARATOR  : ID_OR_VEL | VERTICAL_BAR | SEMICOLON;

TAIL_SEPARATOR  : COMMA;

PARAM_SEPARATOR : COMMA;


input:
     | input line
//     | error { parser_errors++; }
     ;


line:
    clause
    | namespace
    | maxinteger
//          | query
    ;

maxinteger:
    MAXINTEGER EQUALS number
        {
            std::stringstream minum;

            minum << *$3;

            global::maxint = "#maxint=" + minum.str() + ".";
        }
    ;

namespace:
    NAMESPACE PARAM_OPEN nsdef PARAM_CLOSE NEWLINE
    ;

nsdef:
    ident COMMA ident 
        {
            std::string prefix(*$1);
            std::string ns(*$3);

            if (prefix[0] == '\"')
                prefix = prefix.substr(1, prefix.length() - 2);

            if (ns[0] == '\"')
                ns = ns.substr(1, ns.length() - 2);

            Term::namespaces.push_back(std::pair<std::string, std::string>(ns, prefix));

            delete $1;
            delete $3;
        }
//    | ident { Term::namespaces.push_back(std::pair<std::string, std::string>($1, "")); }
    ;

clause:
    rule
//          | strictrule
    | constraint
    | wconstraint
        {
            program.addWeakConstraint($1);
        }
    ;

//meta_rule : import
//          | export
//          ;

/* import    : META_IMPORT PARAM_OPEN ID COMMA ID COMMA ID COMMA ID COMMA ID
 *             COMMA ID PARAM_CLOSE DOT;
 * export    : META_EXPORT PARAM_OPEN ID COMMA ID COMMA ID COMMA ID COMMA ID
 *             PARAM_CLOSE DOT
 *           | META_EXPORT PARAM_OPEN ID COMMA ID COMMA ID COMMA ID COMMA ID
 *             COMMA ID PARAM_CLOSE DOT
 *           ;
 */


/*
strictrule: rule0 EXCLAMATION
          ;
*/


rule:
    rule0 DOT
    ;

constraint:
    CONS body DOT
        {
            //
            // create empty rule head
            //
            RuleHead_t rh;
            
            //
            // create new rule
            //
            $$ = new Rule(rh, *$2, "", (@1.end-1).line);

            //
            // Storing the rule as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            Registry::Instance()->storeObject($$);

            program.addRule($$);

            //
            // the rule was created with head and body copies, so we can delete
            // these:
            //
            delete $2;
        }
    ;

wconstraint:
    WEAK_CONS body DOT
        {
            $$ = new WeakConstraint(*$2, Term(1), Term(1));
        }
    | WEAK_CONS body DOT BRACKET_OPEN COLON ident_or_number BRACKET_CLOSE
        {
            $$ = new WeakConstraint(*$2, Term(1), *$6);

            delete $6;
        }
    | WEAK_CONS body DOT BRACKET_OPEN ident_or_fixedpt COLON BRACKET_CLOSE
        {
            $$ = new WeakConstraint(*$2, *$5, Term(1));

            delete $5;
        }
    | WEAK_CONS body DOT BRACKET_OPEN ident_or_fixedpt COLON ident_or_number BRACKET_CLOSE
        {
            $$ = new WeakConstraint(*$2, *$5, *$7);

            delete $5;
            delete $7;
        }
    ;

ident_or_fixedpt:
    ident
        {
            $$ = new Term(*$1);
            delete $1;
        }
    | fixedpt
    ;

ident_or_number:
    ident
        {
            $$ = new Term(*$1);
            delete $1;
        }
    | number
        {
            $$ = new Term(*$1);
            delete $1;
        }
    ;

fixedpt:
    number
        {
            $$ = new Term(*$1);
            delete $1;
        }
 /* | number DOT NUM */
    ;

/*

query     : body BOOL_QUERY
          ;
*/

rule0:
    user_pred
        {
            if (!(**$1).isGround())
                error(yylloc, "fact not safe");
            
            EDB.insert(*$1);

            delete $1;
        }
    | user_pred CONS
        {
            if (!(**$1).isGround())
                error(yylloc, "fact not safe");

            EDB.insert(*$1);

            delete $1;
        }
    | user_pred CONS body
        {
            //
            // create rule head
            //
            RuleHead_t head;
            
            //
            // add atom pointer to rule head
            //
            head.push_back(*$1);

            delete $1;

            //
            // create new rule with head and body
            //
            $$ = new Rule(head, *$3, "", (@1.end-1).line);

            //
            // Storing the rule as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            Registry::Instance()->storeObject($$);

            program.addRule($$);

            //
            // the rule was created with a copy, which we can delete now:
            //
            delete $3;
        }
    | disj
        {
            //
            // create new rule with head and empty body
            //
            $$ = new Rule(*$1, RuleBody_t(), "", (@1.end-1).line);

            //
            // Storing the rule as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            Registry::Instance()->storeObject($$);

            program.addRule($$);

            //
            // the rule was created with a copy of the disjunction, so we can delete
            // this:
            //
            delete $1;
        }
    | disj CONS
        {
            //
            // create new rule with head and empty body
            //
            $$ = new Rule(*$1, RuleBody_t(), "", (@1.end-1).line);

            //
            // Storing the rule as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            Registry::Instance()->storeObject($$);

            program.addRule($$);

            //
            // the rule was created with a copy of the disjunction, so we can delete
            // this:
            //
            delete $1;
        }
    | disj CONS body
        {
            //
            // create new rule
            //
            $$ = new Rule(*$1, *$3, "", (@1.end-1).line);

            //
            // Storing the rule as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            Registry::Instance()->storeObject($$);

            program.addRule($$);

            //
            // the rule was created with head and body copies, so we can delete
            // these:
            //
            delete $1;
            delete $3;
        }
//    | ident PARAM_OPEN number_param DOT DOT number_param PARAM_CLOSE
    ;

disj:
    user_pred HEAD_SEPARATOR user_pred
        {
            //
            // create rule head
            //
            $$ = new RuleHead_t;
            
            //
            // add both atom pointers to rule head
            //
            $$->push_back(*$1);

            delete $1;

            $$->push_back(*$3);
            
            delete $3;

        }
    | disj HEAD_SEPARATOR user_pred
        {
            //
            // add atom pointer to rule head
            //
            $1->push_back(*$3);

            delete $3;

            $$ = $1;
        }
    ;

body:
    literal
        {
            //
            // create rule body
            //
            $$ = new RuleBody_t;
            
            //
            // add literal pointer
            //
            $$->push_back($1);
        }
        
        | body TAIL_SEPARATOR literal
        {
            //
            // add literal pointer to existing rule body
            //
            $1->push_back($3);
            
            $$ = $1;
        }
    ;


literal:
    user_pred
        {
            //
            // create literal with atom
            //
            $$ = new Literal(*$1);

            delete $1;

            //
            // Storing the literal as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            Registry::Instance()->storeObject($$);
        }
    | NOT user_pred
        {
            //
            // create weakly negated literal with atom
            //
            $$ = new Literal(*$2, true);

            delete $2;

            //
            // Storing the literal as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            Registry::Instance()->storeObject($$);
        }
        
    | external_atom
        {
            //
            // create literal with external atom
            //
            AtomPtr ap($1);
            $$ = new Literal(ap);

            //
            // Storing the literal as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            Registry::Instance()->storeObject($$);
        }
    | builtin_pred
        {
            //
            // create literal with builtin predicate
            //
            AtomPtr ap($1);
            $$ = new Literal(ap);

            //
            // Storing the literal as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            Registry::Instance()->storeObject($$);
        }
//    | aggregate
//    | NOT aggregate
    ;
          


user_pred:
    propositional_atom
        {
            //
            // pass the already created atom
            //
            $$ = $1;
        }
    | PARAM_OPEN terms PARAM_CLOSE
        {
            //
            // create atom from a tuple
            //
            Atom* a = new Atom(*$2);

            //
            // Storing the atom as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            $$ = new AtomPtr(Registry::Instance()->storeAtom(a));

            delete $2;
        }
    | ident PARAM_OPEN terms PARAM_CLOSE
        {
            //
            // create atom from predicate name and arguments
            //
            Atom* a = new Atom(*$1, *$3);

            //
            // Storing the atom as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            $$ = new AtomPtr(Registry::Instance()->storeAtom(a));

            delete $1;
            delete $3;
        }
    | TRUE_NOT PARAM_OPEN terms PARAM_CLOSE
        {
            //
            // create negated atom from a tuple
            //
            Atom* a = new Atom(*$3, 1);

            //
            // Storing the atom as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            $$ = new AtomPtr(Registry::Instance()->storeAtom(a));

            delete $3;
        }
    | TRUE_NOT ident PARAM_OPEN terms PARAM_CLOSE
        {
            //
            // create negated atom from predicate name and arguments
            //
            //Atom* a = new Atom((std::string)$2, *$4, 1);
            Atom* a = new Atom(*$2, *$4, 1);

            //
            // Storing the atom as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            $$ = new AtomPtr(Registry::Instance()->storeAtom(a));

            delete $2;
            delete $4;
        }
    | PRED_INT PARAM_OPEN term PARAM_CLOSE
        {
            //
            // create atom from a term
            //
            Tuple t;
            t.push_back(*$3);
            Atom* a = new Atom("#int", t);
            a->setAlwaysFO();
            $$ = new AtomPtr(Registry::Instance()->storeAtom(a));

            delete $3;
        }
    ;


external_atom:
    AMPERSAND ident BRACKET_OPEN terms BRACKET_CLOSE external_output
        {
            // TODO: two external atoms with same name and input?
            // how "equal" are they?

            //
            // create new external atom from:
            // name string
            // input parameters
            // arguments
            //
            $$ = new ExternalAtom(*$2, *$6, *$4, (@1.end-1).line);

            //
            // Storing the atom as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            Registry::Instance()->storeObject($$);

            delete $2;
            delete $4;
            delete $6;
        }
    ;


external_output:
        {
            //
            // emtpy tuple
            //
            $$ = new Tuple;
        }
    | PARAM_OPEN PARAM_CLOSE
        {
            //
            // emtpy tuple
            //
            $$ = new Tuple;
        }
    | PARAM_OPEN terms PARAM_CLOSE
        {
            $$ = $2;
        }
    ;


propositional_atom:
    ident
        {
            //
            // create new atom from string
            //
            Atom* a;

            //
            // construction of an atom could throw an exception - don't throw
            // same exception again, but use bison's error handler as a general
            // interface for all errors that happen within the parsing.
            //
            try
            {
                a = new Atom(*$1);
            }
            catch (SyntaxError& e)
            {
                error(yylloc, e.what());
            }

            //
            // Storing the atom as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            $$ = new AtomPtr(Registry::Instance()->storeAtom(a));

            delete $1;
        }
    | TRUE_NOT ident
        {
            //
            // create new negated atom from string
            // 
            Atom* a = new Atom(*$2, 1);

            //
            // Storing the atom as a ProgramObject. We don't have to take care
            // of deleting this pointer any more now.
            //
            $$ = new AtomPtr(Registry::Instance()->storeAtom(a));

            delete $2;
        }
    ;


terms:
    term
        {
            $$ = new Tuple;

            //
            // tuple is a vector, term is copied
            //
            $$->push_back(*$1);

            delete $1;
        }
    | terms PARAM_SEPARATOR term
        {
            //
            // tuple is a vector, term is copied
            //
            $1->push_back(*$3);
                    
            $$ = $1;

            delete $3;
        }
    ;


/*
ext_include : EXT_INCLUDE PRED_LESS ident PRED_GREATER NEWLINE
*/


builtin_pred :
    term binop term
        {
            std::stringstream ss;

            ss << *$1 << *$2 << *$3;

            $$ = new BuiltinPredicate(ss.str());

            delete $1;
            delete $2;
            delete $3;
        } 
    | binop PARAM_OPEN term PARAM_SEPARATOR term PARAM_CLOSE
        {
            std::stringstream ss;

            ss << *$3 << *$1 << *$5;

            $$ = new BuiltinPredicate(ss.str());

            delete $1;
            delete $3;
            delete $5;
        }
/*          | PRED_SUCC terms2
          | tertop terms3
          | param_sans_maxint EQUALS term tertop term
          | MAXINTEGER_EQUALS_param tertop term
          */
	  ;

/*
aggregate : term PRED_LESS aggregate_pred
          | term PRED_LESS_OR_EQ aggregate_pred
          | param_sans_maxint EQUALS aggregate_pred
          | term PRED_GREATER_OR_EQ aggregate_pred
          | term PRED_GREATER aggregate_pred
          | aggregate_pred PRED_LESS term
          | aggregate_pred PRED_LESS_OR_EQ term
          | aggregate_pred EQUALS term
          | aggregate_pred PRED_GREATER_OR_EQ term
          | aggregate_pred PRED_GREATER term
          | term PRED_LESS aggregate_pred PRED_LESS term
          | term PRED_LESS aggregate_pred PRED_LESS_OR_EQ term
          | term PRED_LESS_OR_EQ aggregate_pred PRED_LESS term
          | term PRED_LESS_OR_EQ aggregate_pred PRED_LESS_OR_EQ term
          ;
*/

binop    : PRED_EQUAL { $$ = new std::string("=="); }
         | PRED_UNEQUAL { $$ = new std::string("!="); }
         | PRED_LESS { $$ = new std::string("<"); }
         | PRED_GREATER { $$ = new std::string(">"); }
         | PRED_LESS_OR_EQ { $$ = new std::string("<="); }
         | PRED_GREATER_OR_EQ { $$ = new std::string(">="); }
         ;

/*
tertop   : PLUS
         | ASTERISK
	 ;

aggregate_pred : aggregate_type CURLY_OPEN terms COLON body CURLY_CLOSE
         ;

aggregate_type: PRED_ANY
         | PRED_AVG
         | PRED_COUNT
         | PRED_MAX
         | PRED_MIN
         | PRED_SUM                   
         | PRED_TIMES
         ;
	  
terms1   : PARAM_OPEN term PARAM_CLOSE
         ;

terms2   : PARAM_OPEN term PARAM_SEPARATOR term PARAM_CLOSE
         ;

terms3   : PARAM_OPEN term PARAM_SEPARATOR term PARAM_SEPARATOR term PARAM_CLOSE
         ;
*/

term:
    ident
        {
            //
            // make a string term
            //
            $$ = new Term(*$1);

            delete $1;
        }
    | number
        {
            //
            // make a number term
            //
            $$ = new Term(*$1);

            delete $1;
        }
    | ANON_VAR
        {
            //
            /// @todo: are we handling this correctly?
            //
            $$ = new Term();
        }
//         | maxinteger
//         | TRUE_NOT term
    ;


/*
param_sans_maxint : ident
         | number_param
         | ANON_VAR
         ;
*/


ident:
    ID
        {
            $$ = $1;
        }
    | ID_OR_VEL
        {
            $$ = new std::string("v");
        }
    ; 

    /*
number_param:
    number
        {
            $$ = $1;
        }
    ;
    */

number :
    NUM 
    ;



%%


//
// error method of bison parser -> call error method of the
// corresponding driver
//
void
yy::HexParser::error(const yy::HexParser::location_type& l,
                     const std::string& m)
{
    driver->error(l, m);
}


//
// abuse YY_DECL as bison callback for a pure C++ parsing engine
//
YY_DECL
{
    HexFlexLexer* lex = driver->getLexer();
    lex->lexval = yylval; // set current semantic value
    lex->lexloc = yylloc; // and the current location,
    return lex->yylex (); // finally call the drivers lexer
} 

