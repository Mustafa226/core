%{
//////////////////////////////////////////////////////////////////////////////
// DLVresultParser.ypp

#include <iostream>

#include "dlvhex/Term.h"
#include "dlvhex/Atom.h"
#include "dlvhex/AtomSet.h"
#include "dlvhex/Registry.h"
#include "dlvhex/ASPsolver.h"
#include "dlvhex/globals.h"

extern "C" int dlvresulterror(const char*);
extern "C" int dlvresultlex();

namespace solverResult
{
    extern unsigned returncode;
}


//////////////////////////////////////////////////////////////////////////////

#define YYDEBUG 1
%}

%name-prefix="dlvresult"



%union {
    char*          string;
    Term*          term;
    Tuple*         tuple;
    Atom*          gatom;
    AtomSet*       answerset;
    }


%type  <string> ident
%type  <term> groundterm
%type  <tuple> groundterms
%type  <gatom> fact
%type  <answerset> factlist


%token <string> ID NUM MESSAGE
%token ERROR
%token NEWLINE
%token COMMA
%token TRUE_NOT
%token CURLY_OPEN CURLY_CLOSE PARAM_OPEN PARAM_CLOSE

%%

result:
    dlvresult NUM NEWLINE 
        {
            solverResult::returncode = atoi($2);

            delete[] $2;
        }
    ;

dlvresult:
    result_line
    | dlvresult result_line
    | ERROR
    ;

result_line:
    NEWLINE
    | MESSAGE NEWLINE
        {
            solverResult::addMessage($1);

            delete[] $1;
        }
    | CURLY_OPEN factlist CURLY_CLOSE NEWLINE
    ;

factlist:
        {
            $$ = solverResult::createNewAnswerset();
        }
    | fact
        {
            $$ = solverResult::createNewAnswerset();

            AtomPtr ap = Registry::Instance()->dispatch($1);

            //
            // inserting the smart pointer into the AtomSet. If no other copy of
            // it is made there (i.e., actually in the AtomFactory, if this atom
            // already exists there), the object will be automatically destroyed
            // as soon as this scope is left (whatever this scope is in bison).
            // If a copy was made (i.e., because this atom is new), the smart
            // pointer's internal reference count is increased and the object
            // will continue living.
            //
            $$->insert(ap);
        }
    | factlist COMMA fact
        {
            //
            // cf. comment above.
            //
            AtomPtr ap = Registry::Instance()->dispatch($3);

            $1->insert(ap);

            $$ = $1;
        }
    ;

fact:
    ident
        {
            //
            // create new atom from string
            //
            // we cannot use AtomPtr already here because bison doesn't allow
            // semantical types with constructors.
            // 
            $$ = new Atom($1);

            //
            // delete char*
            //
            delete[] $1;
        }
    | TRUE_NOT ident
        {
            $$ = new Atom($2, 1);

            delete[] $2;
        }
    | ident PARAM_OPEN groundterms PARAM_CLOSE
        {
            //
            // in higher-order mode, we throw away the
            // (meaningless) predicate symbol
            //
            if (global::optionNoPredicate)
            {
                $$ = new Atom(*$3);
            }
            else
            {
                $$ = new Atom(std::string($1), *$3);
            }
            
            //
            // atom constructors took a copy from terms, so we can delete them
            // now
            //
            delete $3;
            
            //
            // delete char*
            //
            delete[] $1;
        }
    | TRUE_NOT ident PARAM_OPEN groundterms PARAM_CLOSE
        {
            //
            // in higher-order mode, we throw away the
            // (meaningless) predicate symbol
            //
            if (global::optionNoPredicate)
            {
                $$ = new Atom(*$4, 1);
            }
            else
            {
                $$ = new Atom(std::string($2), *$4, 1);
            }
            
            //
            // atom constructors took a copy from terms, so we can delete them
            // now
            //
            delete $4;
            
            //
            // delete char*
            //
            delete[] $2;
        }
    ;

groundterms:
    groundterm
        {
            $$ = new Tuple;

            $$->push_back(*$1);

            delete $1;
        }
    | groundterms COMMA groundterm
        {
            $1->push_back(*$3);
                
            $$ = $1;
        
            delete $3;
        }
    ;

groundterm:
    ident
        {
            //
            // create new term
            //
            $$ = new Term($1);

            //
            // delete char*
            //
            delete[] $1;
        }
    ;

ident:
    ID
    | NUM
    ;


%%


int dlvresulterror(char const* s) // Error handler for YACC
{
    std::cerr << "internal dlv result parser error: " << s << std::endl;

    return 0;
}





// Local Variables:
// mode: c++
// c-file-style: "dl"
// End:
