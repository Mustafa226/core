/* -*- C++ -*- */

/**
 * @file   DLVresultParser.ypp
 * @author Roman Schindlauer
 * @date   Thu Apr 13 14:42:30 CEST 2006
 * 
 * @brief  A bison C++ parser for DLV result.
 * 
 */


//
// select the C++ parser LALR(1) skeleton
//
%skeleton "lalr1.cc"

//
// overwrite bison default class name "parser":
//
%define "parser_class_name" "DLVresultParser"

//
// produce header file for the scanner
//
%defines

//
// Specify a prefix to use for all bison output file names
//
%file-prefix = "DLVresultParser"


%{

#include <iostream>

#include "dlvhex/DLVresultParserDriver.h"
#include "dlvhex/Term.h"
#include "dlvhex/Atom.h"
#include "dlvhex/AtomSet.h"
#include "dlvhex/Registry.h"
#include "dlvhex/ASPsolver.h"
#include "dlvhex/globals.h"

class DLVresultParserDriver;

%}

//%name-prefix="DLVresult"

// this is the parsing context, passed as parameters to the
// yy::DLVresultParser ctor
%parse-param { DLVresultParserDriver* driver }
%parse-param { std::vector<AtomSet>& answersets }
%parse-param { std::string& dlvError }


// bison passes the driver as additional parameter to the lexer
// function YY_DECL, so we can abuse the driver to get the real lexer
// object and call the yylex() method
%lex-param   { DLVresultParserDriver* driver }

// use a yy::location object to keep track of the location information
%locations

// debug parser
//%debug
//%error-verbose
//%verbose /* really verbose output */


%union {
    std::string*   string;
    int*           integ;
    Term*          term;
    Tuple*         tuple;
    Atom*          gatom;
    AtomSet*       answerset;
}


// define FlexLexer part *after* the definitions of the various types
%{

#include "dlvhex/DLVresultFlexLexer.h"

//
// Flex expects the signature of yylex to be defined in the macro YY_DECL, and
// the C++ parser expects it to be declared.
//
// Announce to bison the prototype we want for the lexing function
#ifndef YY_DECL
#define YY_DECL                                            \
yy::DLVresultParser::token_type                            \
yylex (yy::DLVresultParser::semantic_type* yylval,         \
       yy::DLVresultParser::location_type* yylloc,         \
       DLVresultParserDriver* driver)
// declare YY_DECL function for the parser
YY_DECL;
#endif

%}

%type  <string> ident
%type  <term> groundterm
%type  <tuple> groundterms
%type  <gatom> fact
%type  <answerset> factlist


%token <string> ID MESSAGE
%token <integ> NUM
%token ERROR
%token NEWLINE
%token COMMA
%token TRUE_NOT
%token CURLY_OPEN CURLY_CLOSE PARAM_OPEN PARAM_CLOSE

%start dlvresult

//%printer    { debug_stream() << *$$; } ID

%%

dlvresult: /* empty */
    | dlvresult result_line
    ;

result_line:
    NEWLINE
    | list
    | message //result_line
    ;

message: MESSAGE
    {
        dlvError += std::string(*$1) + "\n";

	delete $1;
    }
    ;

list: CURLY_OPEN factlist CURLY_CLOSE NEWLINE
    ;

factlist:
        {
            answersets.push_back(AtomSet());

            $$ = &(answersets.back());
        }
    | fact
        {
            answersets.push_back(AtomSet());

            $$ = &(answersets.back());

            AtomPtr ap = Registry::Instance()->storeAtom($1);

            //
            // inserting the smart pointer into the AtomSet. If no other copy of
            // it is made there (i.e., actually in the AtomFactory, if this atom
            // already exists there), the object will be automatically destroyed
            // as soon as this scope is left (whatever this scope is in bison).
            // If a copy was made (i.e., because this atom is new), the smart
            // pointer's internal reference count is increased and the object
            // will continue living.
            //
            $$->insert(ap);
        }
    | factlist COMMA fact
        {
            //
            // cf. comment above.
            //
            AtomPtr ap = Registry::Instance()->storeAtom($3);

            $1->insert(ap);

            $$ = $1;
        }
    ;

fact:
    ident
        {
            //
            // create new atom from string
            //
            // we cannot use AtomPtr already here because bison doesn't allow
            // semantical types with constructors.
            // 
            $$ = new Atom(*$1);

            delete $1;
        }
    | TRUE_NOT ident
        {
            $$ = new Atom(*$2, 1);

            delete $2;
        }
    | ident PARAM_OPEN groundterms PARAM_CLOSE
        {
            //
            // in higher-order mode, we throw away the
            // (meaningless) predicate symbol
            //
            if (Globals::Instance()->getOption("NoPredicate"))
            {
                $$ = new Atom(*$3);
            }
            else
            {
                $$ = new Atom(*$1, *$3);
            }
            
            //
            // atom constructors took a copy from terms, so we can delete them
            // now
            //
            delete $3;
            
            delete $1;
        }
    | TRUE_NOT ident PARAM_OPEN groundterms PARAM_CLOSE
        {
            //
            // in higher-order mode, we throw away the
            // (meaningless) predicate symbol
            //
            if (Globals::Instance()->getOption("NoPredicate"))
            {
                $$ = new Atom(*$4, 1);
            }
            else
            {
                $$ = new Atom(*$2, *$4, 1);
            }
            
            //
            // atom constructors took a copy from terms, so we can delete them
            // now
            //
            delete $4;
            
            delete $2;
        }
    ;

groundterms:
    groundterm
        {
            $$ = new Tuple;

            $$->push_back(*$1);

            delete $1;
        }
    | groundterms COMMA groundterm
        {
            $1->push_back(*$3);
                
            $$ = $1;
        
            delete $3;
        }
    ;

groundterm:
    ident
        {
            //
            // create new term
            //
            $$ = new Term(*$1);

            delete $1;
        }
    | NUM
        {
            //
            // create new term
            //
            $$ = new Term(*$1);

            delete $1;
        }
    ;

ident:
    ID
    ;


%%


//
// error method of bison parser -> call error method of the
// corresponding driver
//
void
yy::DLVresultParser::error(const yy::DLVresultParser::location_type& l,
			   const std::string& m)
{
    driver->error(l, m);
}

 
//
// abuse YY_DECL as bison callback for a pure C++ parsing engine
//
YY_DECL
{
    DLVresultFlexLexer* lex = driver->getLexer();
    lex->lexval = yylval; // set current semantic value
    lex->lexloc = yylloc; // and the current location,
    return (yy::DLVresultParser::token_type) lex->yylex (); // finally call the drivers lexer
} 



// Local Variables:
// mode: c++
// c-file-style: "dl"
// End:
