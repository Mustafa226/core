/* dlvhex -- Answer-Set Programming with external interfaces.
 * Copyright (C) 2005, 2006, 2007 Roman Schindlauer
 * 
 * This file is part of dlvhex.
 *
 * dlvhex is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * dlvhex is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with dlvhex; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 */


/**
 * @file   DLVresultParser.ypp
 * @author Roman Schindlauer
 * @date   Thu Apr 13 14:42:30 CEST 2006
 * 
 * @brief  A bison C++ parser for DLV result.
 * 
 */


//
// select the C++ parser LALR(1) skeleton
//
%skeleton "lalr1.cc"

//
// overwrite bison default class name "parser":
//
%define "parser_class_name" "DLVresultParser"

//
// produce header file for the scanner
//
%defines

//
// Specify a prefix to use for all bison output file names
//
%file-prefix = "DLVresultParser"


%{

#include <iostream>

#include "dlvhex/DLVresultParserDriver.h"
#include "dlvhex/Term.h"
#include "dlvhex/Atom.h"
#include "dlvhex/AtomSet.h"
#include "dlvhex/Registry.h"
#include "dlvhex/globals.h"

DLVHEX_NAMESPACE_BEGIN
class DLVresultParserDriver;
DLVHEX_NAMESPACE_END

%}

//%name-prefix="DLVresult"

// this is the parsing context, passed as parameters to the
// yy::DLVresultParser ctor
%parse-param { DLVHEX_NAMESPACE DLVresultParserDriver* driver }
%parse-param { std::vector<DLVHEX_NAMESPACE AtomSet>& answersets }
%parse-param { std::string& dlvError }


// bison passes the driver as additional parameter to the lexer
// function YY_DECL, so we can abuse the driver to get the real lexer
// object and call the yylex() method
%lex-param   { DLVHEX_NAMESPACE DLVresultParserDriver* driver }

// use a yy::location object to keep track of the location information
%locations

// debug parser
//%debug
//%error-verbose
//%verbose /* really verbose output */


%union {
    std::string*   string;
    char*          charp;
    int            integer;
    DLVHEX_NAMESPACE Term*          term;
    DLVHEX_NAMESPACE Tuple*         tuple;
    DLVHEX_NAMESPACE Atom*          gatom;
    DLVHEX_NAMESPACE AtomSet*       answerset;
}


// define FlexLexer part *after* the definitions of the various types
%{

#include "dlvhex/DLVresultFlexLexer.h"

//
// Flex expects the signature of yylex to be defined in the macro YY_DECL, and
// the C++ parser expects it to be declared.
//
// Announce to bison the prototype we want for the lexing function
#ifndef YY_DECL
#define YY_DECL                                            \
yy::DLVresultParser::token_type                            \
yylex (yy::DLVresultParser::semantic_type* yylval,         \
       yy::DLVresultParser::location_type* yylloc,         \
       DLVHEX_NAMESPACE DLVresultParserDriver* driver)
// declare YY_DECL function for the parser
YY_DECL;
#endif

DLVHEX_NAMESPACE_USE

%}

%type  <charp> ident
%type  <term> groundterm
%type  <tuple> groundterms
%type  <gatom> fact
%type  <answerset> factlist


%token <charp> ID
%token <string> MESSAGE
%token <integer> NUM
%token ERROR
%token NEWLINE
%token COMMA
%token TRUE_NOT
%token CURLY_OPEN CURLY_CLOSE PARAM_OPEN PARAM_CLOSE

%start dlvresult

//%printer    { debug_stream() << *$$; } ID

%%

dlvresult: /* empty */
    | dlvresult result_line
    ;

result_line:
    NEWLINE
    | list
    | message //result_line
    ;

message: MESSAGE
    {
        dlvError += std::string(*$1) + "\n";

	delete $1;
    }
    ;

list: CURLY_OPEN factlist CURLY_CLOSE NEWLINE
    ;

factlist:
        {
            answersets.push_back(AtomSet());

            $$ = &(answersets.back());
        }
    | fact
        {
            answersets.push_back(AtomSet());

            $$ = &(answersets.back());

            AtomPtr ap = Registry::Instance()->storeAtom($1);

            //
            // inserting the smart pointer into the AtomSet. If no other copy of
            // it is made there (i.e., actually in the AtomFactory, if this atom
            // already exists there), the object will be automatically destroyed
            // as soon as this scope is left (whatever this scope is in bison).
            // If a copy was made (i.e., because this atom is new), the smart
            // pointer's internal reference count is increased and the object
            // will continue living.
            //
            $$->insert(ap);
        }
    | factlist COMMA fact
        {
            //
            // cf. comment above.
            //
            AtomPtr ap = Registry::Instance()->storeAtom($3);

            $1->insert(ap);

            $$ = $1;
        }
    ;

fact:
    ident
        {
            //
            // create new atom from string
            //
            // we cannot use AtomPtr already here because bison doesn't allow
            // semantical types with constructors.
            // 
            $$ = new Atom($1);

            free($1);
        }
    | TRUE_NOT ident
        {
            $$ = new Atom($2, 1);

            free($2);
        }
    | ident PARAM_OPEN groundterms PARAM_CLOSE
        {
            //
            // in higher-order mode, we throw away the
            // (meaningless) predicate symbol
            //
            if (Globals::Instance()->getOption("NoPredicate"))
            {
                $$ = new Atom(*$3);
            }
            else
            {
                $$ = new Atom($1, *$3);
            }
            
            //
            // atom constructors took a copy from terms, so we can delete them
            // now
            //
            delete $3;
            
            free($1);
        }
    | TRUE_NOT ident PARAM_OPEN groundterms PARAM_CLOSE
        {
            //
            // in higher-order mode, we throw away the
            // (meaningless) predicate symbol
            //
            if (Globals::Instance()->getOption("NoPredicate"))
            {
                $$ = new Atom(*$4, 1);
            }
            else
            {
                $$ = new Atom($2, *$4, 1);
            }
            
            //
            // atom constructors took a copy from terms, so we can delete them
            // now
            //
            delete $4;
            
            free($2);
        }
    ;

groundterms:
    groundterm
        {
            $$ = new Tuple;

            $$->push_back(*$1);

            delete $1;
        }
    | groundterms COMMA groundterm
        {
            $1->push_back(*$3);
                
            $$ = $1;
        
            delete $3;
        }
    ;

groundterm:
    ident
        {
            //
            // create new term
            //
            $$ = new Term($1);

            free($1);
        }
    | NUM
        {
            //
            // create new term
            //
            $$ = new Term($1);
        }
    ;

ident:
    ID
    ;


%%


//
// error method of bison parser -> call error method of the
// corresponding driver
//
void
yy::DLVresultParser::error(const yy::DLVresultParser::location_type& l,
			   const std::string& m)
{
    driver->error(l, m);
}

 
//
// abuse YY_DECL as bison callback for a pure C++ parsing engine
//
YY_DECL
{
    DLVresultFlexLexer* lex = driver->getLexer();
    lex->lexval = yylval; // set current semantic value
    lex->lexloc = yylloc; // and the current location,
    return (yy::DLVresultParser::token_type) lex->yylex (); // finally call the drivers lexer
} 


// Local Variables:
// mode: C++
// End:
