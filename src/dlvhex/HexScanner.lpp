/* -*- C++ -*- */

/**
 * @file   HexScanner.lpp
 * @author Roman Schindlauer
 * @date   Tue Mar 21 22:05:23 CET 2006
 * 
 * @brief  Defines FlexLexer::yylex() method.
 * 
 */


%{

#include <iostream>

//
// generated from bison
//
#include "dlvhex/HexParser.hpp"
#include "dlvhex/HexFlexLexer.h"
#include "dlvhex/HexParserDriver.h"


// Max. length of numeric constants. This should match MAX_MAXINT.
#define NUM_LENGTH 9


// We don't need unput, and it can yield a "defined but not used"-warning.
#define YY_NO_UNPUT

#define yylval (*(yy::HexParser::semantic_type*)lexval)
#define yylloc ((yy::HexParser::location_type*)lexloc)
#define driver (*lexdrv)

%}

/*
 * Because there is no #include-like feature we don't need yywrap, we don't need
 * unput either, and we parse an actual file, this is not an interactive session
 * with the user. Finally we enable the scanner tracing features.
 */
%option noyywrap nounput batch

%option yylineno
/* %option debug */


/*
 * we use a custom FlexLexer (see HexFlexLexer.h)
 */
%option c++

%option prefix="hex"
%option yyclass="HexFlexLexer"


BLANK       ([ \t]+)
NEWLINE     (\r?\n)
ANON_VAR    _
ID          ([A-Za-z][A-Za-z_0-9]*)
QUOTED_ID   (\"[^\"]*\")
NUM         ((\-)?[0-9]+)
COMMENT     \%.*


/*
 * Declares start condition wantnewline.
 *
 * Only in state wantnewline a newline
 * token for the parser is generated, while
 * normally newlines are simply skipped.
 */

%s wantnewline

%x comment

%{
// advance the end location after each tokenizing step
#define YY_USER_ACTION  yylloc->columns(yyleng);
%}

%%

%{
  // abbreviate it as token
  typedef yy::HexParser::token token;
%}


<wantnewline>{NEWLINE} { 
    yylloc->lines(yyleng);
    BEGIN(INITIAL);
    return token::NEWLINE;
}

<comment>{NEWLINE} {
    yylloc->lines(yyleng);
    BEGIN(INITIAL);
}


{NEWLINE} {
    yylloc->lines(1);
}

","    return token::COMMA;
"."    return token::DOT;
":"    return token::COLON;
";"    return token::SEMICOLON;
"-" |
"~"    return token::TRUE_NOT;
"!"    return token::EXCLAMATION;
"+"    return token::PLUS;
"*"    return token::ASTERISK;
"="    return token::EQUALS;
"|"    return token::VERTICAL_BAR;
"&"    return token::AMPERSAND;
"#"    return token::SHARP;

"v"    return token::ID_OR_VEL;
"<-" | 
":-"   return token::CONS;

":~"   return token::WEAK_CONS;

"("    return token::PARAM_OPEN;
")"    return token::PARAM_CLOSE;

"["    return token::BRACKET_OPEN;
"]"    return token::BRACKET_CLOSE;

"{"    return token::CURLY_OPEN;
"}"    return token::CURLY_CLOSE;

"=="   return token::PRED_EQUAL;
"<>" |
"!="   return token::PRED_UNEQUAL;
"<"    return token::PRED_LESS;
">"    return token::PRED_GREATER;
"<="   return token::PRED_LESS_OR_EQ;
">="   return token::PRED_GREATER_OR_EQ;

"#any"     return token::PRED_ANY;
"#avg"     return token::PRED_AVG;
"#count"   return token::PRED_COUNT;
"#max"     return token::PRED_MAX;
"#min"     return token::PRED_MIN;
"#sum"     return token::PRED_SUM;
"#times"   return token::PRED_TIMES;

"#include"  return token::EXT_INCLUDE;

"not" |
"non"       return token::NOT;

"?" {
    return token::BOOL_QUERY;
}

#maxint {
    return token::MAXINTEGER;
}

#int {
    return token::PRED_INT;
}

#succ {
    return token::PRED_SUCC;
}

^({BLANK}?)#import {
    /*  BEGIN(wantnewline); return META_IMPORT; */
}

^({BLANK}?)#export {
    /*  BEGIN(wantnewline); return META_EXPORT; */
}

^({BLANK}?)#namespace { 
    BEGIN(wantnewline);
    return token::NAMESPACE;
}

{ANON_VAR} {
    return token::ANON_VAR;
}

{ID} |
{QUOTED_ID} {
    yylval.string = new std::string(yytext);
    return token::ID;
}

{NUM} { 
    if( strlen(yytext) > NUM_LENGTH )
        driver.error(*yylloc, "numeric constant is too long");
    else
        //yylval.string = new std::string(yytext);
        yylval.integ = new int(atoi(yytext));

    return token::NUM; 
}

{COMMENT} {
    BEGIN(comment); /* Skip comments */
}

{BLANK} { /* Skip blanks */     }


. {
    // Anything not matching one of the patterns
    // given above is considered an error.
    driver.error(*yylloc, "invalid character");
}
