%{
//////////////////////////////////////////////////////////////////////////////
// parser.ypp

#include <iostream>
#include <sstream>

#include "dlvhex/Term.h"
#include "dlvhex/Atom.h"
#include "dlvhex/Literal.h"
#include "dlvhex/Rule.h"
#include "dlvhex/ExternalAtom.h"
#include "dlvhex/globals.h"
//#include "dlvhex/AtomFactory.h"


extern "C" int inputerror(const char*);
extern "C" int inputlex();

extern unsigned parser_errors;
extern const char *parser_file;
extern unsigned parser_line;
 
extern Program IDB;
//extern GAtomSet EDB;
extern AtomSet EDB;
//extern std::vector<ExternalAtom> externalAtoms;

//////////////////////////////////////////////////////////////////////////////

%}

%name-prefix="input"

%union {
    char*           string;
    Term*          term;
    Tuple*      terms;
    Atom*          atom;
    ExternalAtom*       extatom;
    Literal*        literal;
    //std::vector<Atom*>* head;
    //std::vector<Literal*>* body;
    RuleHead* disjunction;
    RuleBody* body;
    Rule*           rule;
    BuiltinPredicate* builtin;
/*    BUILTIN        builtin;
    TERMS*         terms;
    TERM*          term;
    Atom*          atom;
    STERM*         sterm;
    STERMLIST*     stermlist;
    DISJUNCTION*   head;
    Literal*       literal;
    CONJUNCTION*   conjunction;
    AGGREGATE_TYPE*aggregate_type;
    AGGREGATEPRED* aggregate_pred;
    Rule*          rule;
    unsigned       integer;
    WEIGHTS*       weights;
    OIDindices*    oids;
    std::vector<std::string>* stringvector;
    */
    }

%token <string> ID NUM EXTERNAL_ATOM_ID
%type  <string> ident
%type  <string> binop
%type  <string> number number_param
//%type  <string> param_sans_maxint
%type  <term> term
//%type  <string> MAXINTEGER_EQUALS_param
//%type  <string> ident_or_fixedpt ident_or_number
//%type  <string> tertop
%type  <terms> terms// terms1 terms2 terms3
//%type  <string> user_pred builtin_pred propositional_atom aggregate external_atom
%type  <atom> propositional_atom user_pred
//%type  <string> builtin_pred aggregate
%type  <literal> literal
%type  <disjunction> disj
%type  <body> body
%type  <rule> rule rule0
%type <extatom> external_atom    
%type <builtin> builtin_pred    
//%type  <string> aggregate_type
//%type  <string> aggregate_pred
//%type  <rule> rule rule0
//%type  <string> strictrule
//%type  <string> weights
//%type  <string> fixedpt
//%type  <string> object_id
//%type  <string> object_ids inherit


%token ERROR

%token NEWLINE
%token COMMA DOT COLON SEMICOLON EXCLAMATION PLUS ASTERISK EQUALS VERTICAL_BAR AMPERSAND

%token ID_OR_VEL CONS WEAK_CONS ANON_VAR
%token PARAM_OPEN PARAM_CLOSE
%token BRACKET_OPEN BRACKET_CLOSE
%token CURLY_OPEN CURLY_CLOSE
%token PRED_EQUAL PRED_UNEQUAL PRED_LESS PRED_GREATER
%token PRED_LESS_OR_EQ PRED_GREATER_OR_EQ
%token PRED_INT PRED_SUCC
%token PRED_ANY PRED_AVG PRED_COUNT PRED_MAX PRED_MIN PRED_SUM PRED_TIMES
%token NOT TRUE_NOT
%token MAXINTEGER
%token NAMESPACE EXT_INCLUDE SHARP

%token BOOL_QUERY
%token META_IMPORT META_EXPORT

%token EXT_MAPPING_OP_PLUS EXT_MAPPING_OP_MINUS

%start input
%%

HEAD_SEPARATOR  : ID_OR_VEL | VERTICAL_BAR | SEMICOLON;

TAIL_SEPARATOR  : COMMA;

PARAM_SEPARATOR : COMMA;

//OBJECTID_SEPARATOR : COMMA;


input:
     | input line
//     | error { parser_errors++; }
     ;

/* line      : meta_rule NEWLINE
 *           | clause
 *           | query
 *           | MAXINTEGER_EQUALS_param DOT
 *           ;
 */

line:
    clause
    | namespace
//          | query
    ;

/* clauses   :
 *           | clauses clause
 *           ;
 */

namespace:
    NAMESPACE PARAM_OPEN nsdef PARAM_CLOSE
    ;

nsdef:
    ident COMMA ident 
    {
        std::string prefix($1);
        std::string ns($3);

        if (prefix[0] == '\"')
            prefix = prefix.substr(1, prefix.length() - 2);

        if (ns[0] == '\"')
            ns = ns.substr(1, ns.length() - 2);

        Term::namespaces.push_back(std::pair<std::string, std::string>(ns, prefix));

        //
        // delete char*
        //
        delete[] $1;
        delete[] $3;
    }
//    | ident { Term::namespaces.push_back(std::pair<std::string, std::string>($1, "")); }
    ;

clause:
    rule
//          | strictrule
//          | constraint        { } 
//          | wconstraint       { } 
    ;

//MAXINTEGER_EQUALS_param : MAXINTEGER EQUALS term
//                        ;

//meta_rule : import
//          | export
//          ;

/* import    : META_IMPORT PARAM_OPEN ID COMMA ID COMMA ID COMMA ID COMMA ID
 *             COMMA ID PARAM_CLOSE DOT;
 * export    : META_EXPORT PARAM_OPEN ID COMMA ID COMMA ID COMMA ID COMMA ID
 *             PARAM_CLOSE DOT
 *           | META_EXPORT PARAM_OPEN ID COMMA ID COMMA ID COMMA ID COMMA ID
 *             COMMA ID PARAM_CLOSE DOT
 *           ;
 */


/*
strictrule: rule0 EXCLAMATION
          ;
*/


rule:
    rule0 DOT
    ;

rule0:
    user_pred
        {
            if (!(*$1).isGround())
            {
                inputerror("fact not safe.");

                parser_errors++;
            }

            EDB.insert(*$1);
            //AtomFactory::Instance()->insert(*$1);

            delete $1;
        }
    | user_pred CONS
        {
            if (!(*$1).isGround())
            {
                inputerror("fact not safe.");

                parser_errors++;
            }

            EDB.insert(*$1);

            delete $1;
        }
    | user_pred CONS body
        {
            //
            // create rule head
            //
            RuleHead head;
            
            //
            // add atom pointer to rule head
            //
            head.push_back($1);

            //
            // create new rule with head and body
            //
            $$ = new Rule(head, *$3);

            IDB.addRule($$);

            //
            // the rule was created with a copy, which we can delete now:
            //
            delete $3;
        }
    | disj
        {
            //
            // create new rule with head and empty body
            //
            $$ = new Rule(*$1, RuleBody());

            IDB.addRule($$);

            //
            // the rule was created with a copy of the disjunction, so we can delete
            // this:
            //
            delete $1;
        }
    | disj CONS
        {
            //
            // create new rule with head and empty body
            //
            $$ = new Rule(*$1, RuleBody());

            IDB.addRule($$);

            //
            // the rule was created with a copy of the disjunction, so we can delete
            // this:
            //
            delete $1;
        }
    | disj CONS body
        {
            //
            // create new rule
            //
            $$ = new Rule(*$1, *$3);

            IDB.addRule($$);

            //
            // the rule was created with head and body copies, so we can delete
            // these:
            //
            delete $1;
            delete $3;
        }
//    | ident PARAM_OPEN number_param DOT DOT number_param PARAM_CLOSE
    ;

/*
constraint: CONS body DOT
          ;

wconstraint: WEAK_CONS body DOT weights
          ;

weights   : { }
	  | BRACKET_OPEN COLON ident_or_number BRACKET_CLOSE
	  | BRACKET_OPEN ident_or_fixedpt COLON BRACKET_CLOSE
	  | BRACKET_OPEN ident_or_fixedpt COLON ident_or_number BRACKET_CLOSE
	  ;

ident_or_fixedpt : ident
          | fixedpt
          ;

ident_or_number : ident
          | number
          ;

fixedpt	  : number
	  | number DOT NUM
	  ;

query     : body BOOL_QUERY
          ;
*/

disj:
    user_pred HEAD_SEPARATOR user_pred
        {
            //
            // create rule head
            //
            $$ = new RuleHead;
            
            //
            // add both atom pointers to rule head
            //
            $$->push_back($1);

            $$->push_back($3);
            
        }
    | disj HEAD_SEPARATOR user_pred
        {
            //
            // add atom pointer to rule head
            //
            $1->push_back($3);

            $$ = $1;
        }
    ;

body:
    literal
        {
            //
            // create rule body
            //
            $$ = new RuleBody;
            
            //
            // add literal pointer
            //
            $$->push_back($1);
        }
        
        | body TAIL_SEPARATOR literal
        {
            //
            // add literal pointer to existing rule body
            //
            $1->push_back($3);
            
            $$ = $1;
        }
    ;


literal:
    user_pred
        {
            //
            // create literal with atom
            //
            $$ = new Literal($1);
            
            ProgramRepository::Instance()->record($$);
        }
    | NOT user_pred
        {
            //
            // create weakly negated literal with atom
            //
            $$ = new Literal($2, true);

            ProgramRepository::Instance()->record($$);
        }
        
    | external_atom
        {
            //
            // create literal with external atom
            //
            $$ = new Literal($1);

            ProgramRepository::Instance()->record($$);
        }
    | builtin_pred
        {
            //
            // create literal with builtin predicate
            //
            $$ = new Literal($1);

            ProgramRepository::Instance()->record($$);
        }
//    | aggregate
//    | NOT aggregate
    ;
          


user_pred:
    propositional_atom
        {
            //
            // pass the already created atom
            //
            $$ = $1;
        }
    | ident PARAM_OPEN terms PARAM_CLOSE
        {
            //
            // create atom from predicate name and arguments
            //
            $$ = new Atom(std::string($1), *$3);

            ProgramRepository::Instance()->record($$);
            
            //
            // delete terms
            //
            delete $3;
            
            //
            // delete char*
            //
            delete[] $1;
        }
    | TRUE_NOT ident PARAM_OPEN terms PARAM_CLOSE
        {
            //
            // create negated atom from predicate name and arguments
            //
            $$ = new Atom((std::string)$2, *$4, 1);

            ProgramRepository::Instance()->record($$);
            
            //
            // delete terms
            //
            delete $4;
            
            //
            // delete char*
            //
            delete[] $2;
        }
    ;


external_atom:
    AMPERSAND ident BRACKET_OPEN terms BRACKET_CLOSE PARAM_OPEN terms PARAM_CLOSE
        {
            // TODO: two external atoms with same name and input?
            // how "equal" are they?

            //
            // create new external atom from:
            // name string
            // input parameters
            // arguments
            //
            $$ = new ExternalAtom($2, *$7, *$4, parser_line);

            //
            // register external atom
            //
            ProgramRepository::Instance()->record($$);

            //
            // delete char*
            //
            delete[] $2;

            //
            // delete terms
            //
            delete $4;
            delete $7;
        }
    ;



propositional_atom:
    ident
        {
            //
            // create new atom from string
            // 
            $$ = new Atom($1);

            //
            // register atom
            //
            ProgramRepository::Instance()->record($$);

            //
            // delete char*
            //
            delete[] $1;
        }
    | TRUE_NOT ident
        {
            //
            // create new negated atom from string
            // 
            $$ = new Atom($2, 1);

            //
            // register atom
            //
            ProgramRepository::Instance()->record($$);

            //
            // delete char*
            //
            delete[] $2;
        }
    ;


terms:
        {
            //
            // emtpy tuple
            //
            $$ = new Tuple;
        }
    | term
        {
            $$ = new Tuple;

            //
            // tuple is a vector, term is copied
            //
            $$->push_back(*$1);

            //
            // delete term
            //
            delete $1;
        }
    | terms PARAM_SEPARATOR term
        {
            //
            // tuple is a vector, term is copied
            //
            $1->push_back(*$3);
                    
            $$ = $1;
            
            //
            // delete term
            //
            delete $3;
        }
    ;


/*
ext_include : EXT_INCLUDE PRED_LESS ident PRED_GREATER NEWLINE
*/


builtin_pred : /*binop terms2
          |*/ term binop term
           {
               std::ostringstream s;
               s << *$1 << $2 << *$3;
//               std::cout << "creating builtin: " << s.str() << std::endl;
               $$ = new BuiltinPredicate(s.str());

               delete $1;
               delete $3;
           }
          /*| PRED_INT terms1
          | PRED_SUCC terms2
          | tertop terms3
          | param_sans_maxint EQUALS term tertop term
          | MAXINTEGER_EQUALS_param tertop term
          */
	  ;

/*
aggregate : term PRED_LESS aggregate_pred
          | term PRED_LESS_OR_EQ aggregate_pred
          | param_sans_maxint EQUALS aggregate_pred
          | term PRED_GREATER_OR_EQ aggregate_pred
          | term PRED_GREATER aggregate_pred
          | aggregate_pred PRED_LESS term
          | aggregate_pred PRED_LESS_OR_EQ term
          | aggregate_pred EQUALS term
          | aggregate_pred PRED_GREATER_OR_EQ term
          | aggregate_pred PRED_GREATER term
          | term PRED_LESS aggregate_pred PRED_LESS term
          | term PRED_LESS aggregate_pred PRED_LESS_OR_EQ term
          | term PRED_LESS_OR_EQ aggregate_pred PRED_LESS term
          | term PRED_LESS_OR_EQ aggregate_pred PRED_LESS_OR_EQ term
          ;
*/

binop    : PRED_EQUAL { $$ = "=="; }
         | PRED_UNEQUAL { $$ = "!="; }
         | PRED_LESS { $$ = "<"; }
         | PRED_GREATER { $$ = ">"; }
         | PRED_LESS_OR_EQ { $$ = "<="; }
         | PRED_GREATER_OR_EQ { $$ = ">="; }
         ;

/*
tertop   : PLUS
         | ASTERISK
	 ;

aggregate_pred : aggregate_type CURLY_OPEN terms COLON body CURLY_CLOSE
         ;

aggregate_type: PRED_ANY
         | PRED_AVG
         | PRED_COUNT
         | PRED_MAX
         | PRED_MIN
         | PRED_SUM                   
         | PRED_TIMES
         ;
	  
terms1   : PARAM_OPEN term PARAM_CLOSE
         ;

terms2   : PARAM_OPEN term PARAM_SEPARATOR term PARAM_CLOSE
         ;

terms3   : PARAM_OPEN term PARAM_SEPARATOR term PARAM_SEPARATOR term PARAM_CLOSE
         ;
*/

term:
    ident
        {
            //
            // make a string term
            //
            $$ = new Term($1);

            //
            // delete the char*
            //
            delete[] $1;
        }
    | number_param
        {
            //
            // make a number term
            //
            $$ = new Term($1);

            //
            // delete the char*
            //
            delete[] $1;
        }
    | ANON_VAR
        {
            //
            /// @todo: are we handling this correctly?
            //
            $$ = new Term();
        }
//         | maxinteger
//         | TRUE_NOT term
    ;


/*
param_sans_maxint : ident
         | number_param
         | ANON_VAR
         ;
*/


ident:
    ID
        {
            $$ = $1;
        }
    | ID_OR_VEL
        {
            $$ = new char[2];
            $$[0] = 'v';
            $$[1] = 0;
        }
    ; 

number_param: number { $$ = $1; }
         ;

number   : NUM 
	  ;

/*
maxinteger : MAXINTEGER
         ;
*/

%%

int inputerror(char const* s) // Error handler for YACC
{
    if( strlen(parser_file) > 0 )
        std::cerr << parser_file << ": ";
    std::cerr << "line " << parser_line;
    
    std::cerr << ": ";
    
    std::cerr << s << "." << std::endl;
        
    parser_errors++;

    return 1;
}

